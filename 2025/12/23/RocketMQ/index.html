<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>RocketMQ | 欢迎来到chen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="RocketMQ 是阿里开源的分布式消息中间件，因高吞吐、低延迟、支持事务消息等特性被广泛应用，面试中常围绕其架构、核心特性、可靠性、高可用等展开。以下是常见面试题及核心要点： 一、基础概念与架构 什么是 RocketMQ？它有哪些核心特点？  定义：RocketMQ 是基于 Java 开发的分布式消息中间件，支持发布 &#x2F; 订阅模式，提供消息可靠传递、事务消息、延时消息等功能。 特点：高">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ">
<meta property="og:url" content="http://example.com/2025/12/23/RocketMQ/index.html">
<meta property="og:site_name" content="欢迎来到chen的博客">
<meta property="og:description" content="RocketMQ 是阿里开源的分布式消息中间件，因高吞吐、低延迟、支持事务消息等特性被广泛应用，面试中常围绕其架构、核心特性、可靠性、高可用等展开。以下是常见面试题及核心要点： 一、基础概念与架构 什么是 RocketMQ？它有哪些核心特点？  定义：RocketMQ 是基于 Java 开发的分布式消息中间件，支持发布 &#x2F; 订阅模式，提供消息可靠传递、事务消息、延时消息等功能。 特点：高">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-23T11:30:11.000Z">
<meta property="article:modified_time" content="2025-12-24T03:03:49.828Z">
<meta property="article:author" content="little chen">
<meta property="article:tag" content="测试开发,后端开发，测试">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="欢迎来到chen的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">欢迎来到chen的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个专注于技术分享的博客，详情可访问我的csdn——&gt;id:weixin_73527660</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-RocketMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/23/RocketMQ/" class="article-date">
  <time class="dt-published" datetime="2025-12-23T11:30:11.000Z" itemprop="datePublished">2025-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      RocketMQ
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>RocketMQ 是阿里开源的分布式消息中间件，因高吞吐、低延迟、支持事务消息等特性被广泛应用，面试中常围绕其架构、核心特性、可靠性、高可用等展开。以下是常见面试题及核心要点：</p>
<h3 id="一、基础概念与架构"><a href="#一、基础概念与架构" class="headerlink" title="一、基础概念与架构"></a>一、基础概念与架构</h3><ol>
<li><p><strong>什么是 RocketMQ？它有哪些核心特点？</strong></p>
<ul>
<li>定义：RocketMQ 是基于 Java 开发的分布式消息中间件，支持发布 &#x2F; 订阅模式，提供消息可靠传递、事务消息、延时消息等功能。</li>
<li>特点：高吞吐（百万级 TPS）、低延迟（毫秒级）、支持海量消息堆积、事务消息、延时消息、广播 &#x2F; 集群消费、多语言客户端等。</li>
</ul>
</li>
<li><p><strong>RocketMQ 的核心角色有哪些？各自的作用是什么？</strong></p>
<ul>
<li><strong>Producer</strong>：消息生产者，负责发送消息到 Broker。</li>
<li><strong>Consumer</strong>：消息消费者，从 Broker 拉取 &#x2F; 推送消息并消费。</li>
<li><strong>Broker</strong>：消息存储节点，接收 Producer 消息并存储，供 Consumer 拉取；分为 Master 和 Slave（主从架构，保证高可用）。</li>
<li><strong>NameServer</strong>：路由注册中心，管理 Broker 节点信息（地址、主题路由等），提供轻量级服务发现；无状态，可集群部署。</li>
</ul>
</li>
<li><p><strong>RocketMQ 与 Kafka、RabbitMQ 的区别？</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>RocketMQ</th>
<th>Kafka</th>
<th>RabbitMQ</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>高（百万级 TPS）</td>
<td>极高（依赖分区，百万级）</td>
<td>中（万级 TPS）</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>支持同步 &#x2F; 异步刷盘、主从复制</td>
<td>依赖分区副本和刷盘策略</td>
<td>支持持久化，可靠性较高</td>
</tr>
<tr>
<td>功能特性</td>
<td>事务消息、延时消息、重试机制完善</td>
<td>无事务消息，延时消息需自定义</td>
<td>插件丰富，支持复杂路由（如死信、延迟）</td>
</tr>
<tr>
<td>适用场景</td>
<td>分布式事务、高吞吐业务</td>
<td>日志收集、大数据流处理</td>
<td>业务解耦、复杂路由场景</td>
</tr>
</tbody></table>
</li>
<li><p><strong>RocketMQ 的主题（Topic）和队列（Queue）是什么关系？</strong></p>
<ul>
<li>Topic 是消息的逻辑分类（如 “订单消息”“支付消息”），是消息收发的逻辑入口。</li>
<li>Queue 是 Topic 的物理分区，每个 Topic 包含多个 Queue（默认 4 个），分布在不同 Broker 上。</li>
<li>作用：通过 Queue 实现负载均衡（Producer 轮询发送到不同 Queue，Consumer 分配不同 Queue 消费），提高并行处理能力。</li>
</ul>
</li>
</ol>
<h3 id="二、核心流程与原理"><a href="#二、核心流程与原理" class="headerlink" title="二、核心流程与原理"></a>二、核心流程与原理</h3><ol>
<li><strong>Producer 发送消息的流程是什么？</strong><ol>
<li>Producer 启动时，通过配置的 NameServer 地址列表，与任意一个 NameServer 建立连接，获取 Topic 对应的 Broker 路由信息（哪些 Broker 上有该 Topic 的 Queue）。</li>
<li>根据负载均衡策略（默认轮询）选择一个 Queue（属于某个 Broker 的 Master）。</li>
<li>向目标 Broker 发送消息（同步 &#x2F; 异步 &#x2F; 单向），Broker 接收后存储到 CommitLog，并返回确认。</li>
</ol>
</li>
<li><strong>Consumer 消费消息的流程是什么？</strong><ol>
<li>Consumer 启动时，连接 NameServer 获取 Topic 路由信息，知道该消费哪些 Broker 的 Queue。</li>
<li>若为集群消费（默认）：Consumer 组内的消费者通过负载均衡（如平均分配、一致性哈希）分配 Queue（每个 Queue 只被一个消费者消费）。</li>
<li>消费者通过拉取（Pull）或推送（Push，底层是 Pull 封装）方式从 Broker 拉取消息，消费完成后提交消费位点（Offset）。</li>
</ol>
</li>
<li><strong>NameServer 的作用是什么？它是如何与 Broker 交互的？</strong><ul>
<li>作用：管理 Broker 节点元数据（地址、Topic 与 Queue 映射关系），提供路由查询服务（Producer&#x2F;Consumer 可查询 Topic 对应的 Broker 列表）。</li>
<li>交互：<ul>
<li>Broker 启动时向所有 NameServer 注册自己的信息（地址、Topic 配置等）。</li>
<li>Broker 定期（30s）向 NameServer 发送心跳，NameServer 若 120s 未收到心跳，则移除该 Broker 信息。</li>
<li>NameServer 无集群同步，各节点独立存储数据（Producer&#x2F;Consumer 会连接多个 NameServer 保证路由可用性）。</li>
</ul>
</li>
</ul>
</li>
<li>**Broker 的存储结构是什么？有哪些核心文件？**Broker 的消息存储基于文件系统，核心文件包括：<ul>
<li><strong>CommitLog</strong>：所有消息的统一存储文件（顺序写入，提高性能），每条消息包含完整元数据（Topic、Queue、内容等）。</li>
<li><strong>ConsumeQueue</strong>：消息消费的索引文件，按 Topic+Queue 维度划分，每条记录存储消息在 CommitLog 中的偏移量、长度、Tag 哈希值（加速 Consumer 按 Queue 拉取消息）。</li>
<li><strong>IndexFile</strong>：消息索引文件，支持按 Key 或时间范围查询消息（如根据业务 Key 查消息）。</li>
</ul>
</li>
</ol>
<h3 id="三、消息可靠性与顺序性"><a href="#三、消息可靠性与顺序性" class="headerlink" title="三、消息可靠性与顺序性"></a>三、消息可靠性与顺序性</h3><ol>
<li><p>**RocketMQ 如何保证消息不丢失？**需从 “生产、存储、消费” 三阶段保障：</p>
<ul>
<li><p><strong>生产阶段</strong>：Producer 采用同步发送（<code>send()</code> 阻塞等待确认），确保 Broker 成功接收并返回确认（若失败重试）。</p>
</li>
<li><p>存储阶段</p>
<p>：</p>
<ul>
<li>刷盘策略：Broker 配置为 “同步刷盘”（消息写入内存后立即刷盘，不丢失，但性能略低），而非 “异步刷盘”（批量刷盘，可能丢失未刷盘消息）。</li>
<li>主从复制：Broker 配置为 “同步复制”（Master 收到消息后，等待 Slave 复制完成再返回确认），避免 Master 宕机丢失消息。</li>
</ul>
</li>
<li><p><strong>消费阶段</strong>：Consumer 消费完成后再提交 Offset（默认机制），若消费失败不提交，Broker 会重试发送。</p>
</li>
</ul>
</li>
<li><p><strong>RocketMQ 如何保证消息的顺序性？</strong></p>
<ul>
<li><p>顺序性分为 “全局顺序” 和 “局部顺序”：</p>
<ul>
<li><p>局部顺序</p>
<p>：同一业务流程的消息（如同一订单的创建、支付、发货）发送到同一个 Queue（因 Queue 是单线程写入 &#x2F; 消费，天然有序）。</p>
<ul>
<li>实现：Producer 发送时指定 Queue 选择策略（如按订单 ID 哈希到固定 Queue）。</li>
</ul>
</li>
<li><p><strong>全局顺序</strong>：需将 Topic 的 Queue 数设为 1（仅一个 Queue），但会严重影响吞吐量，适用于极少数场景（如金融交易流水）。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>什么是事务消息？RocketMQ 如何实现？</strong></p>
<ul>
<li>事务消息：用于分布式事务场景，保证本地事务与消息发送的原子性（要么都成功，要么都失败）。</li>
<li>实现流程（两阶段提交 + 回查）：<ol>
<li>Producer 发送 “半事务消息”（Half Message）到 Broker，Broker 标记为 “暂不可消费”。</li>
<li>半消息发送成功后，Producer 执行本地事务（如数据库操作）。</li>
<li>根据本地事务结果，Producer 向 Broker 发送 “提交” 或 “回滚” 指令：<ul>
<li>提交：Broker 标记消息为 “可消费”，Consumer 可消费。</li>
<li>回滚：Broker 删除半消息。</li>
</ul>
</li>
<li>若 Producer 崩溃导致未发送指令，Broker 会定期（默认 60s）回查 Producer 本地事务状态，根据结果处理（补偿机制）。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="四、高可用与负载均衡"><a href="#四、高可用与负载均衡" class="headerlink" title="四、高可用与负载均衡"></a>四、高可用与负载均衡</h3><ol>
<li><p><strong>Broker 的主从架构如何保证高可用？</strong></p>
<ul>
<li>Broker 分为 Master 和 Slave：<ul>
<li>Master 负责接收 Producer 消息，支持读写；Slave 仅负责同步 Master 数据，支持读（Consumer 可从 Slave 拉取消息）。</li>
<li>当 Master 宕机，Slave 不会自动切换为 Master，但 Producer 会感知 Master 不可用，将消息发送到其他 Master；Consumer 可从 Slave 消费，保证消息不中断。</li>
<li>需配合 “同步复制” 确保 Slave 数据与 Master 一致（Master 宕机后，Slave 数据完整）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RocketMQ 的负载均衡策略有哪些？（Producer 发送与 Consumer 消费）</strong></p>
<ul>
<li><p><strong>Producer 发送负载均衡</strong>：默认按 “轮询” 策略选择 Topic 下的 Queue（遍历所有 Queue，依次发送），也可自定义（如按消息 Key 哈希）。</p>
</li>
<li><p>Consumer 消费负载均衡（集群模式）</p>
<p>：</p>
<ul>
<li>平均分配：将 Queue 平均分给 Consumer 组内的消费者（如 8 个 Queue 分给 2 个消费者，各分 4 个）。</li>
<li>一致性哈希：按 Consumer ID 哈希到哈希环，Queue 也哈希到环上，就近分配（适合 Consumer 动态变化场景）。</li>
<li>配置策略：通过 <code>AllocateMessageQueueStrategy</code> 接口自定义。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>NameServer 集群如何保证高可用？</strong></p>
<ul>
<li>NameServer 是无状态节点，各节点独立存储 Broker 信息（不互相通信）。</li>
<li>部署多个 NameServer 节点（如 3 个），Producer&#x2F;Consumer 配置所有 NameServer 地址列表，启动时随机连接一个，若连接失败会切换到其他节点。</li>
<li>即使部分 NameServer 宕机，只要有一个存活，就能提供路由服务，保证整体可用性。</li>
</ul>
</li>
</ol>
<h3 id="五、进阶特性与问题处理"><a href="#五、进阶特性与问题处理" class="headerlink" title="五、进阶特性与问题处理"></a>五、进阶特性与问题处理</h3><ol>
<li><p><strong>延时消息的实现原理是什么？</strong></p>
<ul>
<li>延时消息：消息发送后，不立即被消费，而是延迟指定时间（如 5s、10min）后可消费。</li>
<li>原理：<ol>
<li>延时消息发送时，先被存储到 “延时队列”（系统 Topic：<code>SCHEDULE_TOPIC_XXXX</code>），并根据延时级别（如 level&#x3D;3 对应 10s）存入对应 Queue（每个级别一个 Queue）。</li>
<li>Broker 内部有定时任务，每隔 1s 扫描各延时 Queue，将到期的消息（当前时间 ≥ 发送时间 + 延时时间）转移到原 Topic 的 Queue 中，供 Consumer 消费。</li>
</ol>
</li>
<li>注意：延时级别固定（18 级，如 1s、5s、10s…2h），不支持自定义，需业务层二次处理。</li>
</ul>
</li>
<li><p><strong>死信队列是什么？有什么作用？</strong></p>
<ul>
<li>死信队列：当消息消费失败且重试次数达到上限（默认 16 次），会被移入 “死信队列”（系统 Topic：<code>%DLQ%+ConsumerGroupName</code>）。</li>
<li>作用：保存消费失败的消息，供后续人工排查问题（如消息格式错误、依赖服务长期故障），避免影响正常消息消费。</li>
</ul>
</li>
<li><p><strong>消息堆积了如何处理？</strong></p>
<ul>
<li>原因：Consumer 消费速度 &lt; Producer 生产速度，或 Consumer 故障。</li>
<li>处理：<ol>
<li>紧急扩容：增加 Consumer 实例（需保证 Consumer 组内实例数 ≤ Queue 数，否则部分实例空闲）。</li>
<li>优化消费逻辑：简化消费代码（如异步处理非核心步骤）、提高并行度（增大消费线程池 <code>consumeThreadMin</code>）。</li>
<li>跳过非关键消息：暂时消费核心消息，非核心消息后续补处理。</li>
<li>监控预警：通过 RocketMQ 监控工具（如 Prometheus）设置堆积量阈值（如 10 万条），及时告警。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>如何处理消息重复消费问题？</strong></p>
<ul>
<li><p>原因：网络波动（Consumer 消费后提交 Offset 失败，Broker 重试发送）、Broker 主从切换（Slave 未同步 Offset，导致重复拉取）。</p>
</li>
<li><p>解决：业务层实现</p>
<p>幂等性</p>
<p>（多次消费结果一致）：</p>
<ul>
<li>基于唯一标识（如消息 Key 或业务 ID），消费前检查是否已处理（如查数据库、Redis 记录）。</li>
<li>用分布式锁确保同一消息仅被处理一次。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RocketMQ 的刷盘机制有哪些？区别是什么？</strong></p>
<ul>
<li>刷盘机制：消息从内存写入磁盘的策略，影响可靠性和性能：<ul>
<li><strong>同步刷盘</strong>：消息写入 PageCache 后，立即调用 <code>fsync</code> 刷盘，刷盘完成后才返回成功（不丢消息，性能低）。</li>
<li><strong>异步刷盘</strong>：消息写入 PageCache 后直接返回成功，由后台线程定期（如 500ms）批量刷盘（可能丢失未刷盘消息，性能高）。</li>
</ul>
</li>
<li>配置：通过 Broker 配置 <code>flushDiskType</code> 控制（<code>SYNC_FLUSH</code>&#x2F;<code>ASYNC_FLUSH</code>）。</li>
</ul>
</li>
<li><p><strong>RocketMQ 如何监控？核心监控指标有哪些？</strong></p>
<ul>
<li>监控工具：RocketMQ 自带的 Dashboard、Prometheus + Grafana（需配置 Exporter）。</li>
<li>核心指标：<ul>
<li>消息收发：TPS（每秒发送 &#x2F; 消费消息数）、消息堆积量（Queue 中未消费消息数）。</li>
<li>可用性：Broker 存活状态、主从同步延迟、NameServer 连接数。</li>
<li>性能：消息平均延迟（发送到消费的时间）、刷盘耗时、复制耗时。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>以上问题覆盖了 RocketMQ 的核心知识点，面试中需结合原理和实际场景理解</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/23/RocketMQ/" data-id="cuideZeFhXvOsRVIga9AzFSeY" data-title="RocketMQ" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/12/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E6%88%98%E5%85%A8%E6%89%8B%E5%86%8C%EF%BC%88%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%89%EF%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E9%AB%98%E9%98%B6%E7%9A%84%E5%85%A8%E5%9C%BA%E6%99%AF%E8%90%BD%E5%9C%B0%E6%8C%87%E5%8D%97/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          数据库实战全手册（终极版）：从基础到高阶的全场景落地指南
        
      </div>
    </a>
  
  
    <a href="/2025/12/23/Redis/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Redis</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" rel="tag">代码拉取</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" rel="tag">文章，博客框架，技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" rel="tag">服务器，游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" rel="tag">权限配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" style="font-size: 10px;">代码拉取</a> <a href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">文章，博客框架，技术</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">服务器，游戏</a> <a href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">权限配置</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">十二月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/25/gitLaB%E9%97%AE%E9%A2%98/">gitLaB问题</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/">大模型微调</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E9%87%8C%E9%9D%A2%E7%9A%84%E2%80%98mcp%E2%80%99%E6%8A%80%E6%9C%AF/">计算机技术里面的‘mcp’技术</a>
          </li>
        
          <li>
            <a href="/2025/12/24/2025-8-19/">2025-8-19</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E9%82%A3%E4%BA%9B%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84-%E8%B6%85%E7%BA%A7%E9%BB%84%E9%87%91-bug-%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%AF%A5%E8%AE%B0%E5%8F%96%E7%9A%84%E8%A1%80%E6%B3%AA%E7%BB%8F%E9%AA%8C/">那些在公司工作中遇到的 &#39;超级黄金 bug&#39;：每个程序员都该记取的血泪经验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 little chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>