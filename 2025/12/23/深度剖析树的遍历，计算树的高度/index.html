<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>深度剖析树的遍历，计算树的高度 | 欢迎来到chen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="深度剖析树的遍历与计算树的高度技术文章大纲引言 树结构在计算机科学中的重要性 遍历与高度计算的基础应用场景（如算法优化、数据处理）  树的遍历方法 深度优先遍历（DFS）  代码中使用的TreeNode（树节点）是二叉树的基本组成单元，每个节点包含：  val：节点存储的值（如整数）  left：指向左子节点的引用（如果没有左子节点则为null）  right：指向右子节点的引用（如果没有右子节点">
<meta property="og:type" content="article">
<meta property="og:title" content="深度剖析树的遍历，计算树的高度">
<meta property="og:url" content="http://example.com/2025/12/23/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/index.html">
<meta property="og:site_name" content="欢迎来到chen的博客">
<meta property="og:description" content="深度剖析树的遍历与计算树的高度技术文章大纲引言 树结构在计算机科学中的重要性 遍历与高度计算的基础应用场景（如算法优化、数据处理）  树的遍历方法 深度优先遍历（DFS）  代码中使用的TreeNode（树节点）是二叉树的基本组成单元，每个节点包含：  val：节点存储的值（如整数）  left：指向左子节点的引用（如果没有左子节点则为null）  right：指向右子节点的引用（如果没有右子节点">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-23T11:52:47.000Z">
<meta property="article:modified_time" content="2025-12-24T02:13:51.368Z">
<meta property="article:author" content="little chen">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="欢迎来到chen的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">欢迎来到chen的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-深度剖析树的遍历，计算树的高度" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/23/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/" class="article-date">
  <time class="dt-published" datetime="2025-12-23T11:52:47.000Z" itemprop="datePublished">2025-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      深度剖析树的遍历，计算树的高度
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="深度剖析树的遍历与计算树的高度技术文章大纲"><a href="#深度剖析树的遍历与计算树的高度技术文章大纲" class="headerlink" title="深度剖析树的遍历与计算树的高度技术文章大纲"></a>深度剖析树的遍历与计算树的高度技术文章大纲</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><ul>
<li>树结构在计算机科学中的重要性</li>
<li>遍历与高度计算的基础应用场景（如算法优化、数据处理）</li>
</ul>
<h4 id="树的遍历方法"><a href="#树的遍历方法" class="headerlink" title="树的遍历方法"></a>树的遍历方法</h4><ul>
<li><p><strong>深度优先遍历（DFS）</strong></p>
<ul>
<li><p>代码中使用的<code>TreeNode</code>（树节点）是二叉树的基本组成单元，每个节点包含：</p>
</li>
<li><p><code>val</code>：节点存储的值（如整数）</p>
</li>
<li><p><code>left</code>：指向左子节点的引用（如果没有左子节点则为<code>null</code>）</p>
</li>
<li><p><code>right</code>：指向右子节点的引用（如果没有右子节点则为<code>null</code>）</p>
</li>
<li><h3 id="一、前序遍历（preOrder）"><a href="#一、前序遍历（preOrder）" class="headerlink" title="一、前序遍历（preOrder）"></a>一、前序遍历（preOrder）</h3><p>前序遍历的顺序是：<strong>根节点 → 左子树 → 右子树</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void preOrder(TreeNode root) &#123;</span><br><span class="line">    // 步骤1：判断当前节点是否为空</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return;  // 空树/空节点无需遍历，直接返回</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 步骤2：访问当前根节点（输出节点值）</span><br><span class="line">    System.out.print(root.val + &quot; &quot;);</span><br><span class="line">    </span><br><span class="line">    // 步骤3：递归遍历左子树（处理左子节点）</span><br><span class="line">    preOrder(root.left);  // 用左子节点作为新的&quot;根节点&quot;重复整个流程</span><br><span class="line">    </span><br><span class="line">    // 步骤4：递归遍历右子树（处理右子节点）</span><br><span class="line">    preOrder(root.right);  // 用右子节点作为新的&quot;根节点&quot;重复整个流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>执行逻辑示例</strong>（以如下二叉树为例）：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
</li>
<li><p>调用<code>preOrder(1)</code>，<code>root</code>不为空，输出<code>1</code></p>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preOrder(2)</span><br></pre></td></tr></table></figure>

<p>（左子节点）：     </p>
<ul>
<li><p><code>root</code>不为空，输出<code>2</code></p>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preOrder(4)</span><br></pre></td></tr></table></figure>

<p>（左子节点）：         </p>
<ul>
<li><code>root</code>不为空，输出<code>4</code></li>
<li>执行<code>preOrder(null)</code>（4 的左子节点）：空节点，返回</li>
<li>执行<code>preOrder(null)</code>（4 的右子节点）：空节点，返回</li>
</ul>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preOrder(5)</span><br></pre></td></tr></table></figure>

<p>（2 的右子节点）：         </p>
<ul>
<li><code>root</code>不为空，输出<code>5</code></li>
<li>左右子节点均为空，返回</li>
</ul>
</li>
</ul>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preOrder(3)</span><br></pre></td></tr></table></figure>

<p>（1 的右子节点）：     </p>
<ul>
<li><code>root</code>不为空，输出<code>3</code></li>
<li>左右子节点均为空，返回</li>
</ul>
</li>
<li><p>最终输出：<code>1 2 4 5 3</code></p>
</li>
<li><h3 id="二、中序遍历（inOrder）"><a href="#二、中序遍历（inOrder）" class="headerlink" title="二、中序遍历（inOrder）"></a>二、中序遍历（inOrder）</h3><p>中序遍历的顺序是：<strong>左子树 → 根节点 → 右子树</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void inOrder(TreeNode root) &#123;</span><br><span class="line">    // 步骤1：判断当前节点是否为空</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return;  // 空树/空节点无需遍历，直接返回</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 步骤2：递归遍历左子树（先处理左子节点）</span><br><span class="line">    inOrder(root.left);  // 用左子节点作为新的&quot;根节点&quot;重复整个流程</span><br><span class="line">    </span><br><span class="line">    // 步骤3：访问当前根节点（输出节点值）</span><br><span class="line">    System.out.print(root.val + &quot; &quot;);</span><br><span class="line">    </span><br><span class="line">    // 步骤4：递归遍历右子树（再处理右子节点）</span><br><span class="line">    inOrder(root.right);  // 用右子节点作为新的&quot;根节点&quot;重复整个流程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>执行逻辑示例</strong>（同上二叉树）：</p>
</li>
<li><p>调用<code>inOrder(1)</code>，<code>root</code>不为空</p>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inOrder(2)</span><br></pre></td></tr></table></figure>

<p>（左子节点）：     </p>
<ul>
<li><pre><code>root
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不为空，执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
inOrder(4)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  （左子节点）： 		</span><br><span class="line"></span><br><span class="line">  - `root`不为空，执行`inOrder(null)`（4 的左子节点）：返回</span><br><span class="line">  - 输出`4`</span><br><span class="line">  - 执行`inOrder(null)`（4 的右子节点）：返回</span><br><span class="line"></span><br><span class="line">- 输出`2`</span><br><span class="line"></span><br><span class="line">- 执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
inOrder(5)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    （2 的右子节点）： 		</span><br><span class="line"></span><br><span class="line">    - `root`不为空，执行`inOrder(null)`（5 的左子节点）：返回</span><br><span class="line">    - 输出`5`</span><br><span class="line">    - 执行`inOrder(null)`（5 的右子节点）：返回</span><br><span class="line"></span><br><span class="line">- 输出`1`</span><br><span class="line"></span><br><span class="line">- 执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
inOrder(3)
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  （1 的右子节点）： 	</span><br><span class="line"></span><br><span class="line">  - `root`不为空，执行`inOrder(null)`（3 的左子节点）：返回</span><br><span class="line">  - 输出`3`</span><br><span class="line">  - 执行`inOrder(null)`（3 的右子节点）：返回</span><br><span class="line"></span><br><span class="line">- 最终输出：`4 2 5 1 3`</span><br><span class="line"></span><br><span class="line">- ### 三、后序遍历（postOrder）</span><br><span class="line"></span><br><span class="line">  后序遍历的顺序是：**左子树 → 右子树 → 根节点**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void postOrder(TreeNode root) {<br>    &#x2F;&#x2F; 步骤1：判断当前节点是否为空（注意：原代码此处有重复判断，修正后如下）<br>    if (root &#x3D;&#x3D; null) {<br>        return;  &#x2F;&#x2F; 空树&#x2F;空节点无需遍历，直接返回<br>    }</p>
<pre><code>// 步骤2：递归遍历左子树（先处理左子节点）
postOrder(root.left);  // 用左子节点作为新的&quot;根节点&quot;重复整个流程

// 步骤3：递归遍历右子树（再处理右子节点）
postOrder(root.right);  // 用右子节点作为新的&quot;根节点&quot;重复整个流程

// 步骤4：访问当前根节点（输出节点值）
System.out.print(root.val + &quot; &quot;);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)</span><br><span class="line"></span><br><span class="line">  **注意**：原代码中`postOrder`方法有重复的`if (root == null)`判断，属于笔误，上面已修正。</span><br><span class="line"></span><br><span class="line">  **执行逻辑示例**（同上二叉树）：</span><br><span class="line"></span><br><span class="line">- 调用`postOrder(1)`，`root`不为空</span><br><span class="line"></span><br><span class="line">- 执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>postOrder(2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（左子节点）： 	</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  root</span><br></pre></td></tr></table></figure>

<p>  不为空，执行</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postOrder(4)</span><br></pre></td></tr></table></figure>

<p>  （左子节点）：         </p>
<ul>
<li><p><code>root</code>不为空，执行<code>postOrder(null)</code>（4 的左子节点）：返回</p>
</li>
<li><p>执行<code>postOrder(null)</code>（4 的右子节点）：返回</p>
</li>
<li><p>输出<code>4</code></p>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postOrder(5)</span><br></pre></td></tr></table></figure>

<p>（2 的右子节点）：         </p>
<ul>
<li><code>root</code>不为空，执行<code>postOrder(null)</code>（5 的左子节点）：返回</li>
<li>执行<code>postOrder(null)</code>（5 的右子节点）：返回</li>
<li>输出<code>5</code></li>
</ul>
</li>
<li><p>输出<code>2</code></p>
</li>
</ul>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postOrder(3)</span><br></pre></td></tr></table></figure>

<p>（1 的右子节点）：     </p>
<ul>
<li><code>root</code>不为空，执行<code>postOrder(null)</code>（3 的左子节点）：返回</li>
<li>执行<code>postOrder(null)</code>（3 的右子节点）：返回</li>
<li>输出<code>3</code></li>
</ul>
</li>
<li><p>输出<code>1</code></p>
</li>
<li><p>最终输出：<code>4 5 2 3 1</code></p>
</li>
<li><h3 id="总结：三种遍历的核心区别"><a href="#总结：三种遍历的核心区别" class="headerlink" title="总结：三种遍历的核心区别"></a>总结：三种遍历的核心区别</h3></li>
<li><p><strong>前序遍历</strong>：先处理根节点，再处理左右子树（根 → 左 → 右）</p>
</li>
<li><p><strong>中序遍历</strong>：先处理左子树，再处理根节点，最后处理右子树（左 → 根 → 右）</p>
</li>
<li><p><strong>后序遍历</strong>：先处理左右子树，最后处理根节点（左 → 右 → 根）</p>
</li>
<li><p>三者的递归逻辑完全相同，<strong>唯一区别是 “访问根节点（输出值）的时机”</strong>。通过递归不断深入左子树，再回溯处理右子树，最终完成整个二叉树的遍历。</p>
</li>
</ul>
</li>
</ul>
<h4 id="树的高度计算"><a href="#树的高度计算" class="headerlink" title="树的高度计算"></a>树的高度计算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取树的高度</span></span><br><span class="line">  <span class="comment">//整棵树的高度 = 左子树的高度和右子树的高度的最大值 + 1</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> getHeight(root.left);  <span class="comment">//获取左子树的高度</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">hr</span> <span class="operator">=</span> getHeight(root.right);  <span class="comment">//获取右子树的高度</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> hl&gt;hr?hl:hr;</span><br><span class="line">      <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这段代码用于计算二叉树的高度（也称为深度），采用了递归的思想。二叉树的高度定义为：从根节点到最远叶子节点的路径上的节点总数（或边数，这里实现的是节点数计数方式）。下面我会逐行详细解释每一步的执行逻辑。</p>
<h3 id="前提：二叉树高度的定义"><a href="#前提：二叉树高度的定义" class="headerlink" title="前提：二叉树高度的定义"></a>前提：二叉树高度的定义</h3><ul>
<li>空树的高度为 <code>0</code></li>
<li>非空树的高度 &#x3D; 左子树高度和右子树高度中的最大值 + 1（加 1 是因为要包含当前根节点）</li>
</ul>
<h3 id="代码逐行解析"><a href="#代码逐行解析" class="headerlink" title="代码逐行解析"></a>代码逐行解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int getHeight(TreeNode root) &#123;</span><br><span class="line">    // 步骤1：判断当前节点是否为空</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return 0;  // 空树/空节点的高度为0</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 步骤2：递归计算左子树的高度</span><br><span class="line">    int hl = getHeight(root.left);  // 用左子节点作为新的&quot;根节点&quot;计算高度</span><br><span class="line">    </span><br><span class="line">    // 步骤3：递归计算右子树的高度</span><br><span class="line">    int hr = getHeight(root.right);  // 用右子节点作为新的&quot;根节点&quot;计算高度</span><br><span class="line">    </span><br><span class="line">    // 步骤4：取左右子树高度的最大值</span><br><span class="line">    int max = hl &gt; hr ? hl : hr;  // 三元运算符，等价于 Math.max(hl, hr)</span><br><span class="line">    </span><br><span class="line">    // 步骤5：返回当前树的高度（最大值 + 1，包含当前根节点）</span><br><span class="line">    return max + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="执行逻辑示例（以具体二叉树为例）"><a href="#执行逻辑示例（以具体二叉树为例）" class="headerlink" title="执行逻辑示例（以具体二叉树为例）"></a>执行逻辑示例（以具体二叉树为例）</h3><p>假设我们有如下二叉树（数字表示节点值，不是高度）：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">   /</span><br><span class="line">  6</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>我们调用 <code>getHeight(root)</code> 其中 <code>root</code> 是值为 <code>1</code> 的根节点，看看代码如何计算高度。</p>
<h4 id="第-1-层：计算根节点（1）的高度"><a href="#第-1-层：计算根节点（1）的高度" class="headerlink" title="第 1 层：计算根节点（1）的高度"></a>第 1 层：计算根节点（1）的高度</h4><ol>
<li><code>root</code> 不为空（是节点 1），不进入 <code>if</code> 语句。</li>
<li>执行 <code>int hl = getHeight(root.left)</code> → 计算左子树（节点 2）的高度。</li>
<li>执行 <code>int hr = getHeight(root.right)</code> → 计算右子树（节点 3）的高度。</li>
<li>比较 <code>hl</code> 和 <code>hr</code>，取最大值后 +1，得到整棵树的高度。</li>
</ol>
<h4 id="第-2-层：计算左子树（节点-2）的高度（对应步骤-2-的细节）"><a href="#第-2-层：计算左子树（节点-2）的高度（对应步骤-2-的细节）" class="headerlink" title="第 2 层：计算左子树（节点 2）的高度（对应步骤 2 的细节）"></a>第 2 层：计算左子树（节点 2）的高度（对应步骤 2 的细节）</h4><ol>
<li><code>root</code> 是节点 2（非空），不进入 <code>if</code> 语句。</li>
<li>执行 <code>int hl = getHeight(root.left)</code> → 计算左子树（节点 4）的高度。</li>
<li>执行 <code>int hr = getHeight(root.right)</code> → 计算右子树（节点 5）的高度。</li>
<li>比较后返回 <code>max(hl, hr) + 1</code>。</li>
</ol>
<h4 id="第-3-层：计算节点-4-的高度（节点-2-的左子树）"><a href="#第-3-层：计算节点-4-的高度（节点-2-的左子树）" class="headerlink" title="第 3 层：计算节点 4 的高度（节点 2 的左子树）"></a>第 3 层：计算节点 4 的高度（节点 2 的左子树）</h4><ol>
<li><code>root</code> 是节点 4（非空），不进入 <code>if</code> 语句。</li>
<li>执行 <code>int hl = getHeight(root.left)</code> → 节点 4 的左子节点为 <code>null</code>，调用返回 <code>0</code>。</li>
<li>执行 <code>int hr = getHeight(root.right)</code> → 节点 4 的右子节点为 <code>null</code>，调用返回 <code>0</code>。</li>
<li><code>max(0, 0) = 0</code>，返回 <code>0 + 1 = 1</code> → 节点 4 的高度为 1。</li>
</ol>
<h4 id="第-3-层：计算节点-5-的高度（节点-2-的右子树）"><a href="#第-3-层：计算节点-5-的高度（节点-2-的右子树）" class="headerlink" title="第 3 层：计算节点 5 的高度（节点 2 的右子树）"></a>第 3 层：计算节点 5 的高度（节点 2 的右子树）</h4><ol>
<li><code>root</code> 是节点 5（非空），不进入 <code>if</code> 语句。</li>
<li>执行 <code>int hl = getHeight(root.left)</code> → 计算左子树（节点 6）的高度。</li>
<li>执行 <code>int hr = getHeight(root.right)</code> → 节点 5 的右子节点为 <code>null</code>，返回 <code>0</code>。</li>
<li>比较后返回 <code>max(hl, 0) + 1</code>。</li>
</ol>
<h4 id="第-4-层：计算节点-6-的高度（节点-5-的左子树）"><a href="#第-4-层：计算节点-6-的高度（节点-5-的左子树）" class="headerlink" title="第 4 层：计算节点 6 的高度（节点 5 的左子树）"></a>第 4 层：计算节点 6 的高度（节点 5 的左子树）</h4><ol>
<li><code>root</code> 是节点 6（非空），不进入 <code>if</code> 语句。</li>
<li>执行 <code>int hl = getHeight(root.left)</code> → 节点 6 的左子节点为 <code>null</code>，返回 <code>0</code>。</li>
<li>执行 <code>int hr = getHeight(root.right)</code> → 节点 6 的右子节点为 <code>null</code>，返回 <code>0</code>。</li>
<li><code>max(0, 0) = 0</code>，返回 <code>0 + 1 = 1</code> → 节点 6 的高度为 1。</li>
</ol>
<h4 id="回溯到节点-5-的计算"><a href="#回溯到节点-5-的计算" class="headerlink" title="回溯到节点 5 的计算"></a>回溯到节点 5 的计算</h4><ul>
<li>节点 5 的左子树高度 <code>hl = 1</code>（节点 6 的高度），右子树高度 <code>hr = 0</code>。</li>
<li><code>max(1, 0) = 1</code>，返回 <code>1 + 1 = 2</code> → 节点 5 的高度为 2。</li>
</ul>
<h4 id="回溯到节点-2-的计算"><a href="#回溯到节点-2-的计算" class="headerlink" title="回溯到节点 2 的计算"></a>回溯到节点 2 的计算</h4><ul>
<li>节点 2 的左子树高度 <code>hl = 1</code>（节点 4 的高度），右子树高度 <code>hr = 2</code>（节点 5 的高度）。</li>
<li><code>max(1, 2) = 2</code>，返回 <code>2 + 1 = 3</code> → 节点 2 的高度为 3。</li>
</ul>
<h4 id="第-2-层：计算右子树（节点-3）的高度（对应步骤-3-的细节）"><a href="#第-2-层：计算右子树（节点-3）的高度（对应步骤-3-的细节）" class="headerlink" title="第 2 层：计算右子树（节点 3）的高度（对应步骤 3 的细节）"></a>第 2 层：计算右子树（节点 3）的高度（对应步骤 3 的细节）</h4><ol>
<li><code>root</code> 是节点 3（非空），不进入 <code>if</code> 语句。</li>
<li>执行 <code>int hl = getHeight(root.left)</code> → 节点 3 的左子节点为 <code>null</code>，返回 <code>0</code>。</li>
<li>执行 <code>int hr = getHeight(root.right)</code> → 节点 3 的右子节点为 <code>null</code>，返回 <code>0</code>。</li>
<li><code>max(0, 0) = 0</code>，返回 <code>0 + 1 = 1</code> → 节点 3 的高度为 1。</li>
</ol>
<h4 id="最终回溯到根节点（1）的计算"><a href="#最终回溯到根节点（1）的计算" class="headerlink" title="最终回溯到根节点（1）的计算"></a>最终回溯到根节点（1）的计算</h4><ul>
<li>根节点的左子树高度 <code>hl = 3</code>（节点 2 的高度），右子树高度 <code>hr = 1</code>（节点 3 的高度）。</li>
<li><code>max(3, 1) = 3</code>，返回 <code>3 + 1 = 4</code> → 整棵树的高度为 4。</li>
</ul>
<h3 id="递归过程的核心思想"><a href="#递归过程的核心思想" class="headerlink" title="递归过程的核心思想"></a>递归过程的核心思想</h3><ol>
<li><strong>分解问题</strong>：将 “求整棵树的高度” 分解为 “求左子树高度” 和 “求右子树高度” 两个子问题。</li>
<li><strong>终止条件</strong>：当遇到空节点时，高度为 0（递归不再深入）。</li>
<li><strong>合并结果</strong>：子问题的结果（左右子树高度）取最大值后加 1，得到当前节点为根的树的高度。</li>
</ol>
<p>这个过程就像从叶子节点开始 “自底向上” 计算：先算出最底层叶子的高度，再逐步向上推导出父节点、根节点的高度，最终得到整棵树的高度。</p>
<p>应用场景与优化</p>
<ul>
<li>遍历与高度计算在平衡二叉树（AVL树）中的作用</li>
<li>时间复杂度分析：递归与迭代的对比（O(n) vs O(n)）</li>
<li>空间复杂度优化技巧（如Morris遍历）</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>不同遍历方法的适用场景</li>
<li>高度计算在算法设计中的扩展应用（如动态规划）</li>
</ul>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul>
<li>《算法导论》中树的相关章节</li>
<li>LeetCode典型例题（如104. 二叉树的最大深度）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/23/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6/" data-id="cuid073YD6s-gO4EkP8DSJCN8" data-title="深度剖析树的遍历，计算树的高度" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/12/23/%E5%91%8A%E5%88%AB%E6%A0%BC%E5%BC%8F%E7%83%A6%E6%81%BC%EF%BC%818-%E4%B8%AA%E5%85%8D%E8%B4%B9%E6%96%87%E6%A1%A3%E8%BD%AC%E6%8D%A2%E7%A5%9E%E5%99%A8%EF%BC%8C%E5%9C%A8%E7%BA%BF%E6%90%9E%E5%AE%9A%E6%89%80%E6%9C%89%E6%A0%BC%E5%BC%8F%E9%9A%BE%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          告别格式烦恼！8 个免费文档转换神器，在线搞定所有格式难题
        
      </div>
    </a>
  
  
    <a href="/2025/12/23/2025-%E4%B8%AD%E5%9B%BD%E4%BA%92%E8%81%94%E7%BD%91%E5%A4%A7%E4%BC%9A%EF%BC%8C%E6%96%B0%E7%9A%84%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2025 中国互联网大会，新的发展方向</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" rel="tag">代码拉取</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" rel="tag">文章，博客框架，技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" rel="tag">服务器，游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" rel="tag">权限配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" style="font-size: 10px;">代码拉取</a> <a href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">文章，博客框架，技术</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">服务器，游戏</a> <a href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">权限配置</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/">大模型微调</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E9%87%8C%E9%9D%A2%E7%9A%84%E2%80%98mcp%E2%80%99%E6%8A%80%E6%9C%AF/">计算机技术里面的‘mcp’技术</a>
          </li>
        
          <li>
            <a href="/2025/12/24/2025-8-19/">2025-8-19</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E9%82%A3%E4%BA%9B%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84-%E8%B6%85%E7%BA%A7%E9%BB%84%E9%87%91-bug-%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%AF%A5%E8%AE%B0%E5%8F%96%E7%9A%84%E8%A1%80%E6%B3%AA%E7%BB%8F%E9%AA%8C/">那些在公司工作中遇到的 &#39;超级黄金 bug&#39;：每个程序员都该记取的血泪经验</a>
          </li>
        
          <li>
            <a href="/2025/12/23/Java%E5%92%8Cgo%E8%AF%AD%E8%A8%80%E7%9A%842025%E5%B9%B4%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF%E5%92%8C%E5%B0%B1%E4%B8%9A%E5%BD%A2%E5%8A%BF/">Java和go语言的2025年发展前景和就业形势</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 little chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>