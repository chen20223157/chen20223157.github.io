<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>从原理到实战：数据库索引、切片与四表联查全解析 | 欢迎来到chen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="在后端开发中，数据库是支撑业务的 “基石”，而索引、数据切片、多表联查则是优化数据库性能、处理复杂业务场景的核心技术。不少开发者在初期会被 “索引为什么有时没用”“大数据量怎么拆分表”“多表联查怎么写不卡顿” 等问题困扰。本文将以博客视角，从基础概念到实战案例，用通俗的语言 + 可复现的代码，带你吃透这三个关键技术，让你的数据库操作既 “快” 又 “准”。 一、数据库索引：让查询从 “翻书” 变">
<meta property="og:type" content="article">
<meta property="og:title" content="从原理到实战：数据库索引、切片与四表联查全解析">
<meta property="og:url" content="http://example.com/2025/12/23/%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E3%80%81%E5%88%87%E7%89%87%E4%B8%8E%E5%9B%9B%E8%A1%A8%E8%81%94%E6%9F%A5%E5%85%A8%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="欢迎来到chen的博客">
<meta property="og:description" content="在后端开发中，数据库是支撑业务的 “基石”，而索引、数据切片、多表联查则是优化数据库性能、处理复杂业务场景的核心技术。不少开发者在初期会被 “索引为什么有时没用”“大数据量怎么拆分表”“多表联查怎么写不卡顿” 等问题困扰。本文将以博客视角，从基础概念到实战案例，用通俗的语言 + 可复现的代码，带你吃透这三个关键技术，让你的数据库操作既 “快” 又 “准”。 一、数据库索引：让查询从 “翻书” 变">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-23T11:30:44.000Z">
<meta property="article:modified_time" content="2025-12-24T03:02:09.259Z">
<meta property="article:author" content="little chen">
<meta property="article:tag" content="测试开发,后端开发，测试">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="欢迎来到chen的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">欢迎来到chen的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个专注于技术分享的博客，详情可访问我的csdn——&gt;id:weixin_73527660</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-从原理到实战：数据库索引、切片与四表联查全解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/23/%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E3%80%81%E5%88%87%E7%89%87%E4%B8%8E%E5%9B%9B%E8%A1%A8%E8%81%94%E6%9F%A5%E5%85%A8%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2025-12-23T11:30:44.000Z" itemprop="datePublished">2025-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      从原理到实战：数据库索引、切片与四表联查全解析
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在后端开发中，数据库是支撑业务的 “基石”，而索引、数据切片、多表联查则是优化数据库性能、处理复杂业务场景的核心技术。不少开发者在初期会被 “索引为什么有时没用”“大数据量怎么拆分表”“多表联查怎么写不卡顿” 等问题困扰。本文将以博客视角，从基础概念到实战案例，用通俗的语言 + 可复现的代码，带你吃透这三个关键技术，让你的数据库操作既 “快” 又 “准”。</p>
<h2 id="一、数据库索引：让查询从-“翻书”-变-“定位”"><a href="#一、数据库索引：让查询从-“翻书”-变-“定位”" class="headerlink" title="一、数据库索引：让查询从 “翻书” 变 “定位”"></a>一、数据库索引：让查询从 “翻书” 变 “定位”</h2><p>提到索引，很多人会说 “不就是给字段加个索引吗？”，但实际开发中，常有 “加了索引查询还是慢”“索引太多导致插入卡顿” 的情况。这背后，是对索引原理和使用场景的理解不足。</p>
<h3 id="1-1-什么是索引？用生活案例讲透核心逻辑"><a href="#1-1-什么是索引？用生活案例讲透核心逻辑" class="headerlink" title="1.1 什么是索引？用生活案例讲透核心逻辑"></a>1.1 什么是索引？用生活案例讲透核心逻辑</h3><p>索引本质是<strong>数据库为了加速查询而创建的 “数据目录”</strong>，就像字典的部首目录、书籍的目录 —— 如果没有目录，查 “数据库” 这个词需要从字典第一页翻到最后一页；有了目录，直接定位到对应页码，效率天差地别。</p>
<p>举个实际场景：假设你有一张<code>user</code>表，存储了 100 万用户数据，要查询<code>phone = 13800138000</code>的用户。</p>
<ul>
<li>无索引时：数据库会逐行扫描 100 万条数据（全表扫描），直到找到匹配的记录，可能需要几秒甚至更久；</li>
<li>有索引时：数据库直接查<code>phone</code>字段的索引，找到该手机号对应的 “数据地址”，再去数据表中取数据，耗时可能仅毫秒级。</li>
</ul>
<p>但要注意：索引不是 “越多越好”。字典不会给每个字都单独做目录 —— 索引会占用额外存储空间，且表的插入 &#x2F; 更新 &#x2F; 删除操作会同步维护索引，索引越多，这些操作的效率越低。</p>
<h3 id="1-2-索引的常见类型：不同场景选对-“工具”"><a href="#1-2-索引的常见类型：不同场景选对-“工具”" class="headerlink" title="1.2 索引的常见类型：不同场景选对 “工具”"></a>1.2 索引的常见类型：不同场景选对 “工具”</h3><p>数据库索引有多种类型，不同类型对应不同业务需求，选错类型会导致索引失效或性能浪费。以下是 MySQL 中最常用的 5 种索引，结合场景说明用法：</p>
<table>
<thead>
<tr>
<th>索引类型</th>
<th>核心定义</th>
<th>适用场景</th>
<th>示例 SQL</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>唯一标识表中每条记录，字段非空且唯一</td>
<td>表的主键（如用户 ID、订单 ID）</td>
<td><code>ALTER TABLE user ADD PRIMARY KEY (id);</code></td>
</tr>
<tr>
<td>唯一索引</td>
<td>字段值唯一（允许 NULL，但 NULL 只出现一次）</td>
<td>需唯一约束的字段（如手机号、邮箱）</td>
<td><code>ALTER TABLE user ADD UNIQUE (phone);</code></td>
</tr>
<tr>
<td>普通索引</td>
<td>无特殊约束，仅加速查询</td>
<td>频繁作为查询条件的字段（如用户名、性别）</td>
<td><code>ALTER TABLE user ADD INDEX idx_name (name);</code></td>
</tr>
<tr>
<td>组合索引</td>
<td>对多个字段联合创建索引，遵循 “最左前缀原则”</td>
<td>多字段联合查询（如 “性别 + 年龄” 筛选用户）</td>
<td><code>ALTER TABLE user ADD INDEX idx_gender_age (gender, age);</code></td>
</tr>
<tr>
<td>全文索引</td>
<td>针对文本内容（如文章正文）的模糊查询优化</td>
<td>长文本模糊搜索（如博客内容搜索 “数据库”）</td>
<td><code>ALTER TABLE article ADD FULLTEXT idx_content (content);</code></td>
</tr>
</tbody></table>
<p>这里重点提<strong>组合索引的 “最左前缀原则”</strong>—— 这是索引失效的高频原因。比如创建了<code>idx_gender_age (gender, age)</code>组合索引：</p>
<ul>
<li>有效查询：<code>WHERE gender = &#39;男&#39;</code>（用左 1 字段）、<code>WHERE gender = &#39;男&#39; AND age = 25</code>（用左 1 + 左 2 字段）；</li>
<li>失效查询：<code>WHERE age = 25</code>（跳过左 1 字段，索引不生效，变成全表扫描）。</li>
</ul>
<h3 id="1-3-索引的底层原理：为什么是-B-树？"><a href="#1-3-索引的底层原理：为什么是-B-树？" class="headerlink" title="1.3 索引的底层原理：为什么是 B + 树？"></a>1.3 索引的底层原理：为什么是 B + 树？</h3><p>很多人知道索引用 B + 树实现，但很少想 “为什么不用二叉树、红黑树？”。要理解这个问题，先搞懂 B + 树的结构和优势。</p>
<h4 id="1-3-1-B-树的结构：“矮胖”-的树更高效"><a href="#1-3-1-B-树的结构：“矮胖”-的树更高效" class="headerlink" title="1.3.1 B + 树的结构：“矮胖” 的树更高效"></a>1.3.1 B + 树的结构：“矮胖” 的树更高效</h4><p>B + 树是一种 “多路平衡查找树”，特点是 “层级少、叶子节点存数据”，结构如下：</p>
<ul>
<li>非叶子节点：只存 “索引键” 和 “子节点指针”，不存实际数据，每个节点能存多个索引键（比如 MySQL 默认每个节点 16KB，能存上千个索引键）；</li>
<li>叶子节点：存 “索引键 + 实际数据地址”（InnoDB 引擎），且所有叶子节点用链表连接，方便范围查询（如 “查询 age &gt; 20 且 age &lt; 30”）。</li>
</ul>
<p>举个例子：一张 100 万数据的表，用 B + 树索引时，树的高度通常只有 3 层 —— 根节点 1 层，中间节点 1 层，叶子节点 1 层。查询时最多只需 3 次磁盘 IO（从根节点到叶子节点），而磁盘 IO 是数据库查询的主要耗时项，层数越少，速度越快。</p>
<h4 id="1-3-2-为什么不选其他树？"><a href="#1-3-2-为什么不选其他树？" class="headerlink" title="1.3.2 为什么不选其他树？"></a>1.3.2 为什么不选其他树？</h4><ul>
<li>二叉树：会变成 “链表”（比如数据递增时，树退化成单链），查询需要 O (n) 时间，比全表扫描还慢；</li>
<li>红黑树：虽然是平衡树，但仍是 “二叉”（每个节点最多 2 个子节点），100 万数据需要 20 层左右，磁盘 IO 次数是 B + 树的 7 倍，效率差距巨大；</li>
<li>B 树：与 B + 树类似，但非叶子节点也存数据，导致每个节点存的索引键更少，树的高度更高，且叶子节点不连链表，范围查询需要回溯，效率不如 B + 树。</li>
</ul>
<p>正是因为 B + 树 “层数少、范围查询快” 的特点，成为了数据库索引的最优选择。</p>
<h3 id="1-4-索引实战：避坑指南与优化技巧"><a href="#1-4-索引实战：避坑指南与优化技巧" class="headerlink" title="1.4 索引实战：避坑指南与优化技巧"></a>1.4 索引实战：避坑指南与优化技巧</h3><p>掌握了原理，还要知道实际开发中如何避坑。以下是 5 个高频问题和解决方案：</p>
<h4 id="1-4-1-索引失效的-8-种常见场景"><a href="#1-4-1-索引失效的-8-种常见场景" class="headerlink" title="1.4.1 索引失效的 8 种常见场景"></a>1.4.1 索引失效的 8 种常见场景</h4><ol>
<li><strong>使用函数或运算</strong>：<code>WHERE SUBSTR(phone, 1, 7) = &#39;1380013&#39;</code>（对索引字段用函数，索引失效）；解决方案：改造成<code>WHERE phone LIKE &#39;1380013%&#39;</code>（前缀匹配，索引生效）。</li>
<li><strong>类型转换</strong>：<code>WHERE phone = 13800138000</code>（phone 是 varchar 类型，用数字匹配，索引失效）；解决方案：加引号，<code>WHERE phone = &#39;13800138000&#39;</code>。</li>
<li><strong>不等于（!&#x3D;、&lt;&gt;）</strong>：<code>WHERE age != 25</code>（索引失效，全表扫描）；解决方案：如果业务允许，用<code>WHERE age &gt; 25 OR age &lt; 25</code>（范围查询，索引生效）。</li>
<li><strong>IS NOT NULL</strong>：<code>WHERE email IS NOT NULL</code>（索引失效）；解决方案：尽量让字段有默认值（如空字符串），用<code>WHERE email != &#39;&#39;</code>。</li>
<li><strong>OR 连接非索引字段</strong>：<code>WHERE name = &#39;张三&#39; OR gender = &#39;男&#39;</code>（gender 无索引，整个查询索引失效）；解决方案：给 gender 也加索引，或拆分成两个查询用 UNION 合并。</li>
<li><strong>LIKE 以 % 开头</strong>：<code>WHERE name LIKE &#39;%三&#39;</code>（前缀模糊，索引失效）；解决方案：尽量用后缀匹配（<code>%三</code>不行）或前缀匹配（<code>张%</code>可行），如需全模糊，用全文索引。</li>
<li><strong>组合索引不满足最左前缀</strong>：如前所述，跳过左 1 字段会失效。</li>
<li><strong>MySQL 优化器判断全表扫描更快</strong>：比如表数据少（只有 100 条），MySQL 会直接全表扫描，不使用索引。</li>
</ol>
<h4 id="1-4-2-索引优化的-3-个实战案例"><a href="#1-4-2-索引优化的-3-个实战案例" class="headerlink" title="1.4.2 索引优化的 3 个实战案例"></a>1.4.2 索引优化的 3 个实战案例</h4><p><strong>案例 1：高频查询字段优先加索引</strong>某电商项目中，<code>order</code>表（100 万数据）频繁执行 “查询用户的所有订单”：<code>SELECT * FROM order WHERE user_id = 123</code>。</p>
<ul>
<li>优化前：无<code>user_id</code>索引，查询耗时 1.2 秒；</li>
<li>优化后：添加<code>idx_user_id (user_id)</code>索引，查询耗时 0.03 秒，性能提升 40 倍。</li>
</ul>
<p><strong>案例 2：用组合索引替代多个单列索引</strong>如果频繁执行 “查询男性且 25 岁的用户”：<code>SELECT * FROM user WHERE gender = &#39;男&#39; AND age = 25</code>。</p>
<ul>
<li>错误做法：给 gender 和 age 分别加单列索引，MySQL 只能用其中一个索引，另一个字段仍需扫描；</li>
<li>正确做法：加组合索引<code>idx_gender_age (gender, age)</code>，MySQL 可直接用索引定位到所有匹配数据，耗时减少 60%。</li>
</ul>
<p><strong>案例 3：用覆盖索引减少 “回表”</strong>“回表” 是指：索引只存了索引键，查询时需要先查索引，再去数据表中取其他字段（如<code>SELECT id, name FROM user WHERE gender = &#39;男&#39;</code>，如果索引是<code>idx_gender (gender)</code>，需要先查索引找到 id，再去表中取 name）。</p>
<ul>
<li>优化方案：创建覆盖索引<code>idx_gender_name (gender, name)</code>，索引中已包含 name 字段，无需回表，查询耗时从 0.05 秒降至 0.01 秒。</li>
</ul>
<h3 id="1-5-索引小结"><a href="#1-5-索引小结" class="headerlink" title="1.5 索引小结"></a>1.5 索引小结</h3><ul>
<li>索引是 “加速查询的目录”，但会占用空间、影响写操作，需平衡；</li>
<li>选对索引类型（如组合索引适合多字段查询），避免失效场景；</li>
<li>底层用 B + 树实现，核心优势是 “层数少、范围查询快”；</li>
<li>优化核心：高频查询字段加索引、组合索引替代单列索引、用覆盖索引减少回表。</li>
</ul>
<hr>
<h2 id="二、数据库切片：大数据量下的-“分而治之”"><a href="#二、数据库切片：大数据量下的-“分而治之”" class="headerlink" title="二、数据库切片：大数据量下的 “分而治之”"></a>二、数据库切片：大数据量下的 “分而治之”</h2><p>当表数据量达到千万甚至亿级时，即使加了索引，查询仍会卡顿 —— 这时候需要 “数据切片”（也称数据分片），将大表拆分成多个小表，让每个表的数据量控制在百万级以内，从而提升性能。</p>
<h3 id="2-1-什么是数据库切片？澄清概念误区"><a href="#2-1-什么是数据库切片？澄清概念误区" class="headerlink" title="2.1 什么是数据库切片？澄清概念误区"></a>2.1 什么是数据库切片？澄清概念误区</h3><p>很多开发者会把 “数据库切片” 和 “Python 切片”（如<code>list[1:10]</code>）混淆，其实数据库切片的核心是 <strong>“数据分片”</strong>，即按规则将大表拆分成多个小表，每个小表独立存储，对外仍可视为一个整体。</p>
<p>举个例子：某社交 APP 的<code>message</code>表（10 亿条用户消息），如果存在一个表中，即使查 “2024 年 1 月的消息”，索引也需要扫描大量数据；如果按 “月份” 切片，拆成<code>message_202401</code>、<code>message_202402</code>、<code>message_202403</code>等小表，查询 2024 年 1 月的消息时，只需查<code>message_202401</code>表（约 3000 万数据），速度提升 30 倍以上。</p>
<p>另外，“分页查询”（如<code>LIMIT 100, 20</code>）也可视为 “逻辑切片”—— 从大表中按页截取部分数据，是日常开发中最常用的切片方式。</p>
<h3 id="2-2-切片的两种核心方式：水平切片与垂直切片"><a href="#2-2-切片的两种核心方式：水平切片与垂直切片" class="headerlink" title="2.2 切片的两种核心方式：水平切片与垂直切片"></a>2.2 切片的两种核心方式：水平切片与垂直切片</h3><p>根据拆分规则，切片分为 “水平切片” 和 “垂直切片”，适用场景完全不同，需根据业务选择。</p>
<h4 id="2-2-1-水平切片（按行拆分）：同结构，不同数据"><a href="#2-2-1-水平切片（按行拆分）：同结构，不同数据" class="headerlink" title="2.2.1 水平切片（按行拆分）：同结构，不同数据"></a>2.2.1 水平切片（按行拆分）：同结构，不同数据</h4><p>水平切片是<strong>将表按行拆分</strong>，每个小表的结构完全相同（字段一致），但存储不同范围的数据。比如<code>user</code>表按 “用户 ID 范围” 拆分：</p>
<ul>
<li><code>user_1</code>：存储 id 1~100 万的用户；</li>
<li><code>user_2</code>：存储 id 100 万 + 1~200 万的用户；</li>
<li><code>user_3</code>：存储 id 200 万 + 1~300 万的用户。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>表行数多（千万级以上），但字段少；</li>
<li>查询常按 “分片键” 过滤（如按用户 ID 查数据，按时间查订单）。</li>
</ul>
<p><strong>常见分片规则</strong>：</p>
<ol>
<li>按范围分片：如时间（按月份、按季度）、ID 范围（1~100 万、100 万～200 万）；</li>
<li>按哈希分片：对分片键（如 user_id）做哈希运算，分配到不同表（如<code>user_id % 3</code>，分成 3 个表）；</li>
<li>按地理位置分片：如电商按 “省份” 拆分订单表（<code>order_beijing</code>、<code>order_shanghai</code>）。</li>
</ol>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：可无限扩展（只要增加小表数量），查询时只需访问对应小表；</li>
<li>缺点：跨分片查询复杂（如查 “id 50 万和 150 万的用户”，需要查两个表）。</li>
</ul>
<h4 id="2-2-2-垂直切片（按列拆分）：同数据，不同结构"><a href="#2-2-2-垂直切片（按列拆分）：同数据，不同结构" class="headerlink" title="2.2.2 垂直切片（按列拆分）：同数据，不同结构"></a>2.2.2 垂直切片（按列拆分）：同数据，不同结构</h4><p>垂直切片是<strong>将表按列拆分</strong>，每个小表存储部分字段，共同组成原表的所有字段。比如<code>user</code>表（包含 id、name、phone、avatar、address、intro 等字段）拆分成：</p>
<ul>
<li><code>user_base</code>：存储高频查询字段（id、name、phone）；</li>
<li><code>user_profile</code>：存储低频查询字段（avatar、address、intro）。</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>表字段多（如包含大文本、图片 URL 等），但行数不多；</li>
<li>部分字段查询频繁，部分字段查询极少（如用户头像很少查，但用户名、手机号频繁查）。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li>优点：减少单表字段数，提升查询速度（每个表的数据页能存更多行）；</li>
<li>缺点：扩展受限（字段数固定），关联查询增多（查用户所有信息需关联<code>user_base</code>和<code>user_profile</code>）。</li>
</ul>
<h3 id="2-3-分页查询：最常用的-“逻辑切片”-实战"><a href="#2-3-分页查询：最常用的-“逻辑切片”-实战" class="headerlink" title="2.3 分页查询：最常用的 “逻辑切片” 实战"></a>2.3 分页查询：最常用的 “逻辑切片” 实战</h3><p>分页查询是日常开发中最频繁的切片操作，比如 “列表页显示 10 条数据，点击下一页加载下 10 条”。但很多人会写出 “低效分页 SQL”，导致数据量大时卡顿。</p>
<h4 id="2-3-1-分页查询的基础语法"><a href="#2-3-1-分页查询的基础语法" class="headerlink" title="2.3.1 分页查询的基础语法"></a>2.3.1 分页查询的基础语法</h4><p>MySQL 中分页用<code>LIMIT offset, size</code>，其中：</p>
<ul>
<li><code>offset</code>：偏移量（从第几条开始，默认 0）；</li>
<li><code>size</code>：每页显示的条数。</li>
</ul>
<p>示例：查询用户表第 2 页数据（每页 10 条）：</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, phone FROM user LIMIT 10, 10; -- 从第11条开始，取10条（offset=10=1*10，size=10）</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h4 id="2-3-2-分页查询的性能坑：offset-过大"><a href="#2-3-2-分页查询的性能坑：offset-过大" class="headerlink" title="2.3.2 分页查询的性能坑：offset 过大"></a>2.3.2 分页查询的性能坑：offset 过大</h4><p>当<code>offset</code>很大时（如<code>LIMIT 100000, 10</code>），查询会非常慢 —— 因为 MySQL 会先扫描前 100010 条数据，再丢弃前 100000 条，只返回最后 10 条，相当于全表扫描。</p>
<p><strong>案例</strong>：<code>user</code>表 100 万数据，执行以下两个 SQL：</p>
<ul>
<li><code>LIMIT 100, 10</code>：耗时 0.02 秒；</li>
<li><code>LIMIT 100000, 10</code>：耗时 1.8 秒，性能差距 90 倍。</li>
</ul>
<h4 id="2-3-3-优化方案：用-“主键自增”-定位偏移量"><a href="#2-3-3-优化方案：用-“主键自增”-定位偏移量" class="headerlink" title="2.3.3 优化方案：用 “主键自增” 定位偏移量"></a>2.3.3 优化方案：用 “主键自增” 定位偏移量</h4><p>如果表的主键是自增的（如 id），可以通过 “主键范围” 替代<code>offset</code>，避免全表扫描：</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 优化前：LIMIT 100000, 10（慢）</span><br><span class="line">-- 优化后：先查上一页最后一条的id（假设是100000），再查大于该id的10条数据</span><br><span class="line">SELECT id, name, phone FROM user WHERE id &gt; 100000 LIMIT 10;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>优化后，查询耗时从 1.8 秒降至 0.03 秒，性能提升 60 倍。但这种方案有个限制：需要知道上一页的最后一个主键值，适合 “下一页” 场景，不适合 “跳页”（如直接从第 1 页跳到第 100 页）。</p>
<h4 id="2-3-4-跳页场景的优化：游标分页"><a href="#2-3-4-跳页场景的优化：游标分页" class="headerlink" title="2.3.4 跳页场景的优化：游标分页"></a>2.3.4 跳页场景的优化：游标分页</h4><p>对于需要跳页的场景（如用户直接输入页码跳转），可以用 “游标分页”—— 通过 “分片键 + 主键” 定位，比如按 “创建时间 + id” 排序：</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查第100页数据（每页10条），先算上一页最后一条的create_time和id（假设是&#x27;2024-01-01&#x27;和100000）</span><br><span class="line">SELECT id, name, phone, create_time </span><br><span class="line">FROM user </span><br><span class="line">WHERE create_time &lt;= &#x27;2024-01-01&#x27; AND id &lt; 100000 </span><br><span class="line">ORDER BY create_time DESC, id DESC </span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这种方式利用了 “create_time+id” 的组合索引，避免了大 offset，即使跳页也能快速查询。</p>
<h3 id="2-4-切片实战：电商订单表的分片案例"><a href="#2-4-切片实战：电商订单表的分片案例" class="headerlink" title="2.4 切片实战：电商订单表的分片案例"></a>2.4 切片实战：电商订单表的分片案例</h3><p>某电商平台的<code>order</code>表，数据量达 5000 万条，查询 “用户的订单”“按月统计订单量” 频繁，采用<strong>水平切片（按时间 + 哈希）</strong> 方案，具体如下：</p>
<h4 id="2-4-1-分片规则设计"><a href="#2-4-1-分片规则设计" class="headerlink" title="2.4.1 分片规则设计"></a>2.4.1 分片规则设计</h4><ol>
<li>按 “年份 + 季度” 拆分大表：如<code>order_2024_q1</code>（2024 年 1-3 月）、<code>order_2024_q2</code>（2024 年 4-6 月）；</li>
<li>每个季度表再按 “user_id 哈希” 拆分：如<code>order_2024_q1_0</code>（user_id%3&#x3D;0）、<code>order_2024_q1_1</code>（user_id%3&#x3D;1）、<code>order_2024_q1_2</code>（user_id%3&#x3D;2）；</li>
<li>最终每个小表的数据量控制在 500 万以内（5000 万 &#x2F; 4 季度 &#x2F; 3 哈希 &#x3D; 约 417 万）。</li>
</ol>
<h4 id="2-4-2-分片工具：Sharding-JDBC"><a href="#2-4-2-分片工具：Sharding-JDBC" class="headerlink" title="2.4.2 分片工具：Sharding-JDBC"></a>2.4.2 分片工具：Sharding-JDBC</h4><p>手动管理分片表会很繁琐（如查询时需要自己判断访问哪个表），实际开发中常用<code>Sharding-JDBC</code>（开源分片框架）自动处理：</p>
<ol>
<li>配置分片规则：在配置文件中指定 “按时间拆分表”“按 user_id 哈希拆分”；</li>
<li>透明访问：开发者写 SQL 时仍用原表名（如<code>order</code>），Sharding-JDBC 自动路由到对应的小表；</li>
<li>跨分片查询：如需查 “2024 年 1-4 月的订单”，Sharding-JDBC 自动查询<code>order_2024_q1</code>和<code>order_2024_q2</code>的所有小表，合并结果返回。</li>
</ol>
<h4 id="2-4-3-优化效果"><a href="#2-4-3-优化效果" class="headerlink" title="2.4.3 优化效果"></a>2.4.3 优化效果</h4><ul>
<li>查询 “用户 2024 年 1 月的订单”：从原来的全表扫描（5000 万数据）变为只查<code>order_2024_q1_xx</code>（约 417 万数据），耗时从 2.5 秒降至 0.1 秒；</li>
<li>插入订单：每个小表的写入压力降低，插入耗时从 0.5 秒降至 0.05 秒。</li>
</ul>
<h3 id="2-5-切片小结"><a href="#2-5-切片小结" class="headerlink" title="2.5 切片小结"></a>2.5 切片小结</h3><ul>
<li>切片是 “分而治之” 的思想，解决大表查询卡顿问题；</li>
<li>水平切片按行拆（同结构，不同数据），适合行数多的表；垂直切片按列拆（同数据，不同结构），适合字段多的表；</li>
<li>分页查询是逻辑切片，需避免大 offset，用主键或游标优化；</li>
<li>实战中用 Sharding-JDBC 等工具管理分片，降低开发成本。</li>
</ul>
<hr>
<h2 id="三、四表联查：复杂业务场景的-“数据关联”"><a href="#三、四表联查：复杂业务场景的-“数据关联”" class="headerlink" title="三、四表联查：复杂业务场景的 “数据关联”"></a>三、四表联查：复杂业务场景的 “数据关联”</h2><p>在实际业务中，数据往往分散在多个表中（如用户数据在<code>user</code>表，订单在<code>order</code>表，商品在<code>product</code>表），需要通过 “多表联查” 获取完整数据。四表联查是多表联查的典型场景，掌握它就能应对大部分复杂查询需求。</p>
<h3 id="3-1-多表联查的基础：理解-“关联关系”-与-“笛卡尔积”"><a href="#3-1-多表联查的基础：理解-“关联关系”-与-“笛卡尔积”" class="headerlink" title="3.1 多表联查的基础：理解 “关联关系” 与 “笛卡尔积”"></a>3.1 多表联查的基础：理解 “关联关系” 与 “笛卡尔积”</h3><p>在学四表联查前，必须先搞懂两个基础概念：表的关联关系、笛卡尔积，否则写出来的 SQL 可能会出现 “数据重复” 或 “数据缺失”。</p>
<h4 id="3-1-1-表的三种关联关系"><a href="#3-1-1-表的三种关联关系" class="headerlink" title="3.1.1 表的三种关联关系"></a>3.1.1 表的三种关联关系</h4><p>实际业务中，表与表的关联主要有三种：</p>
<ol>
<li><strong>一对一（1:1）</strong>：如<code>user</code>表和<code>user_profile</code>表（一个用户对应一个个人资料）；</li>
<li><strong>一对多（1:N）</strong>：如<code>user</code>表和<code>order</code>表（一个用户对应多个订单）；</li>
<li><strong>多对多（N:M）</strong>：如<code>order</code>表和<code>product</code>表（一个订单包含多个商品，一个商品被多个订单包含），这种关系需要中间表（如<code>order_product</code>，存储 order_id 和 product_id）。</li>
</ol>
<p>四表联查通常会包含这几种关系，比如 “用户 - 订单 - 订单商品 - 商品” 就是典型的 1:N:N:1 关系。</p>
<h4 id="3-1-2-笛卡尔积：联查的-“陷阱”"><a href="#3-1-2-笛卡尔积：联查的-“陷阱”" class="headerlink" title="3.1.2 笛卡尔积：联查的 “陷阱”"></a>3.1.2 笛卡尔积：联查的 “陷阱”</h4><p>笛卡尔积是指 “两个表所有行的组合”，比如<code>user</code>表有 2 条数据，<code>order</code>表有 3 条数据，笛卡尔积结果有 2*3&#x3D;6 条数据，其中大部分是无效数据（如用户 A 的订单包含用户 B 的信息）。</p>
<p>示例：未加关联条件的联查（产生笛卡尔积）：</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT u.name, o.order_no </span><br><span class="line">FROM user u, order o; -- 未加WHERE关联条件，产生笛卡尔积</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>避免笛卡尔积的核心</strong>：在<code>WHERE</code>子句或<code>JOIN</code>子句中添加 “关联条件”（如<code>u.id = o.user_id</code>），只保留有效的关联数据。</p>
<h3 id="3-2-四表联查的核心语法：JOIN-的四种类型"><a href="#3-2-四表联查的核心语法：JOIN-的四种类型" class="headerlink" title="3.2 四表联查的核心语法：JOIN 的四种类型"></a>3.2 四表联查的核心语法：JOIN 的四种类型</h3><p>多表联查的核心是<code>JOIN</code>关键字，MySQL 支持四种<code>JOIN</code>类型，不同类型决定了 “如何保留两个表的数据”。四表联查本质是 “多次两表联查”，先联查两个表，再用结果联查第三个表，最后联查第四个表。</p>
<h4 id="3-2-1-四种-JOIN-类型对比"><a href="#3-2-1-四种-JOIN-类型对比" class="headerlink" title="3.2.1 四种 JOIN 类型对比"></a>3.2.1 四种 JOIN 类型对比</h4><table>
<thead>
<tr>
<th>JOIN 类型</th>
<th>核心逻辑</th>
<th>通俗理解</th>
<th>示例 SQL（两表联查）</th>
</tr>
</thead>
<tbody><tr>
<td>INNER JOIN</td>
<td>只保留两个表中 “关联条件匹配” 的数据</td>
<td>取两个表的 “交集”</td>
<td><code>SELECT * FROM user u INNER JOIN order o ON u.id = o.user_id;</code></td>
</tr>
<tr>
<td>LEFT JOIN</td>
<td>保留左表所有数据，右表只保留匹配数据，不匹配则为 NULL</td>
<td>左表全要，右表匹配的才要</td>
<td><code>SELECT * FROM user u LEFT JOIN order o ON u.id = o.user_id;</code></td>
</tr>
<tr>
<td>RIGHT JOIN</td>
<td>保留右表所有数据，左表只保留匹配数据，不匹配则为 NULL</td>
<td>右表全要，左表匹配的才要</td>
<td><code>SELECT * FROM user u RIGHT JOIN order o ON u.id = o.user_id;</code></td>
</tr>
<tr>
<td>FULL JOIN</td>
<td>保留两个表所有数据，不匹配则为 NULL</td>
<td>取两个表的 “并集”（MySQL 不直接支持，需用 UNION 实现）</td>
<td><code>SELECT * FROM user u LEFT JOIN order o ON u.id = o.user_id UNION SELECT * FROM user u RIGHT JOIN order o ON u.id = o.user_id;</code></td>
</tr>
</tbody></table>
<p><strong>关键提醒</strong>：四表联查时，每次<code>JOIN</code>都要加 “关联条件”（<code>ON</code>子句），否则会产生笛卡尔积，导致数据量暴增、查询卡顿。</p>
<h4 id="3-2-2-四表联查的语法结构"><a href="#3-2-2-四表联查的语法结构" class="headerlink" title="3.2.2 四表联查的语法结构"></a>3.2.2 四表联查的语法结构</h4><p>以 “用户（user）- 订单（order）- 订单商品（order_product）- 商品（product）” 四表联查为例，语法结构如下：</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  u.id AS user_id,  -- 用户ID</span><br><span class="line">  u.name AS user_name,  -- 用户名</span><br><span class="line">  o.order_no AS order_no,  -- 订单号</span><br><span class="line">  op.quantity AS buy_quantity,  -- 购买数量</span><br><span class="line">  p.name AS product_name  -- 商品名称</span><br><span class="line">FROM user u  -- 第一个表：用户表</span><br><span class="line">INNER JOIN order o ON u.id = o.user_id  -- 联查第二个表：订单表（关联条件：用户ID）</span><br><span class="line">INNER JOIN order_product op ON o.id = op.order_id  -- 联查第三个表：订单商品表（关联条件：订单ID）</span><br><span class="line">INNER JOIN product p ON op.product_id = p.id  -- 联查第四个表：商品表（关联条件：商品ID）</span><br><span class="line">WHERE u.id = 123;  -- 筛选条件：只查用户123的数据</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这个 SQL 的逻辑是：</p>
<ol>
<li>先联查<code>user</code>和<code>order</code>，得到用户 123 的所有订单；</li>
<li>再联查<code>order_product</code>，得到每个订单包含的商品 ID 和购买数量；</li>
<li>最后联查<code>product</code>，得到商品名称，最终返回 “用户 - 订单 - 商品” 的完整数据。</li>
</ol>
<h3 id="3-3-四表联查实战：电商场景案例"><a href="#3-3-四表联查实战：电商场景案例" class="headerlink" title="3.3 四表联查实战：电商场景案例"></a>3.3 四表联查实战：电商场景案例</h3><p>为了让大家更易理解，我们用一个完整的电商场景案例，从 “需求分析” 到 “SQL 编写” 再到 “结果解读”，一步一步实现四表联查。</p>
<h4 id="3-3-1-场景需求"><a href="#3-3-1-场景需求" class="headerlink" title="3.3.1 场景需求"></a>3.3.1 场景需求</h4><p>某电商平台需要实现 “用户订单详情页”，需展示：</p>
<ul>
<li>用户信息：用户名、手机号；</li>
<li>订单信息：订单号、下单时间、订单总金额；</li>
<li>商品信息：每个商品的名称、单价、购买数量、小计金额（单价 * 数量）。</li>
</ul>
<p>涉及的四张表及结构如下：</p>
<ol>
<li><code>user</code>（用户表）：id（主键）、name（用户名）、phone（手机号）；</li>
<li><code>order</code>（订单表）：id（主键）、order_no（订单号）、user_id（外键，关联 user.id）、create_time（下单时间）、total_amount（订单总金额）；</li>
<li><code>order_product</code>（订单商品中间表）：id（主键）、order_id（外键，关联 order.id）、product_id（外键，关联 product.id）、quantity（购买数量）、unit_price（购买时单价）；</li>
<li><code>product</code>（商品表）：id（主键）、name（商品名称）、current_price（当前单价）。</li>
</ol>
<h4 id="3-3-2-编写四表联查-SQL"><a href="#3-3-2-编写四表联查-SQL" class="headerlink" title="3.3.2 编写四表联查 SQL"></a>3.3.2 编写四表联查 SQL</h4><p>根据需求，我们需要用<code>LEFT JOIN</code>（确保即使订单没有商品，也能显示订单信息），并计算 “小计金额”（unit_price * quantity）：</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  -- 用户信息</span><br><span class="line">  u.id AS user_id,</span><br><span class="line">  u.name AS user_name,</span><br><span class="line">  u.phone AS user_phone,</span><br><span class="line">  -- 订单信息</span><br><span class="line">  o.id AS order_id,</span><br><span class="line">  o.order_no AS order_no,</span><br><span class="line">  o.create_time AS order_create_time,</span><br><span class="line">  o.total_amount AS order_total_amount,</span><br><span class="line">  -- 商品信息</span><br><span class="line">  p.id AS product_id,</span><br><span class="line">  p.name AS product_name,</span><br><span class="line">  op.quantity AS buy_quantity,</span><br><span class="line">  op.unit_price AS buy_unit_price,</span><br><span class="line">  -- 计算小计金额（单价*数量）</span><br><span class="line">  op.unit_price * op.quantity AS product_subtotal</span><br><span class="line">FROM user u</span><br><span class="line">-- 联查订单表：用户可能有多个订单，用LEFT JOIN保留所有订单</span><br><span class="line">LEFT JOIN `order` o ON u.id = o.user_id</span><br><span class="line">-- 联查订单商品表：订单可能包含多个商品，用LEFT JOIN保留所有商品</span><br><span class="line">LEFT JOIN order_product op ON o.id = op.order_id</span><br><span class="line">-- 联查商品表：获取商品名称，用LEFT JOIN避免商品删除导致订单信息丢失</span><br><span class="line">LEFT JOIN product p ON op.product_id = p.id</span><br><span class="line">-- 筛选条件：只查用户123的订单，且订单时间在2024年</span><br><span class="line">WHERE </span><br><span class="line">  u.id = 123 </span><br><span class="line">  AND o.create_time &gt;= &#x27;2024-01-01 00:00:00&#x27;</span><br><span class="line">  AND o.create_time &lt; &#x27;2025-01-01 00:00:00&#x27;</span><br><span class="line">-- 排序：按下单时间降序，同一订单的商品按商品ID升序</span><br><span class="line">ORDER BY </span><br><span class="line">  o.create_time DESC,</span><br><span class="line">  p.id ASC;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h4 id="3-3-3-结果解读"><a href="#3-3-3-结果解读" class="headerlink" title="3.3.3 结果解读"></a>3.3.3 结果解读</h4><p>假设用户 123 在 2024 年有 2 个订单，订单 1 包含 2 个商品，订单 2 包含 1 个商品，查询结果如下（简化后）：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>user_name</th>
<th>order_no</th>
<th>product_name</th>
<th>buy_quantity</th>
<th>buy_unit_price</th>
<th>product_subtotal</th>
</tr>
</thead>
<tbody><tr>
<td>123</td>
<td>张三</td>
<td>2024060101</td>
<td>手机 A</td>
<td>1</td>
<td>5999</td>
<td>5999</td>
</tr>
<tr>
<td>123</td>
<td>张三</td>
<td>2024060101</td>
<td>耳机 B</td>
<td>1</td>
<td>299</td>
<td>299</td>
</tr>
<tr>
<td>123</td>
<td>张三</td>
<td>2024051501</td>
<td>充电器 C</td>
<td>2</td>
<td>89</td>
<td>178</td>
</tr>
</tbody></table>
<p>结果符合需求：展示了用户的所有订单，每个订单包含的商品及小计金额，方便前端渲染 “订单详情页”。</p>
<h3 id="3-4-四表联查的性能优化：避免-“联查卡顿”"><a href="#3-4-四表联查的性能优化：避免-“联查卡顿”" class="headerlink" title="3.4 四表联查的性能优化：避免 “联查卡顿”"></a>3.4 四表联查的性能优化：避免 “联查卡顿”</h3><p>四表联查涉及多个表的关联，若不优化，很容易出现 “查询耗时几秒” 的情况。以下是 5 个核心优化技巧，结合案例说明：</p>
<h4 id="3-4-1-给关联字段加索引"><a href="#3-4-1-给关联字段加索引" class="headerlink" title="3.4.1 给关联字段加索引"></a>3.4.1 给关联字段加索引</h4><p>联查的 “瓶颈” 通常是 “关联字段无索引”，导致每次联查都全表扫描。上述案例中，需给以下字段加索引：</p>
<ul>
<li><code>order.user_id</code>（关联<code>user.id</code>）：<code>ALTER TABLE order ADD INDEX idx_user_id (user_id);</code></li>
<li><code>order_product.order_id</code>（关联<code>order.id</code>）：<code>ALTER TABLE order_product ADD INDEX idx_order_id (order_id);</code></li>
<li><code>order_product.product_id</code>（关联<code>product.id</code>）：<code>ALTER TABLE order_product ADD INDEX idx_product_id (product_id);</code></li>
</ul>
<p>加索引后，联查时 MySQL 会通过索引快速定位关联数据，查询耗时从 1.5 秒降至 0.05 秒。</p>
<h4 id="3-4-2-避免-“SELECT-”，只查需要的字段"><a href="#3-4-2-避免-“SELECT-”，只查需要的字段" class="headerlink" title="3.4.2 避免 “SELECT *”，只查需要的字段"></a>3.4.2 避免 “SELECT *”，只查需要的字段</h4><p>“SELECT *” 会查询所有字段，包括不需要的字段（如<code>product</code>表的<code>description</code>大文本字段），增加数据传输量和内存消耗。</p>
<ul>
<li>错误做法：<code>SELECT * FROM user u LEFT JOIN order o ...</code>；</li>
<li>正确做法：如案例中只查<code>user.name</code>、<code>o.order_no</code>等需要的字段，数据传输量减少 70%。</li>
</ul>
<h4 id="3-4-3-用-WHERE-子句提前过滤数据"><a href="#3-4-3-用-WHERE-子句提前过滤数据" class="headerlink" title="3.4.3 用 WHERE 子句提前过滤数据"></a>3.4.3 用 WHERE 子句提前过滤数据</h4><p>在联查前，先用<code>WHERE</code>子句过滤掉不需要的数据，减少联查的数据量。比如案例中 “只查用户 123 的 2024 年订单”，避免联查所有用户的所有订单。</p>
<ul>
<li>优化前：先联查所有数据，再筛选用户 123 的订单；</li>
<li>优化后：先筛选用户 123 的订单，再联查商品数据，联查数据量减少 99%。</li>
</ul>
<h4 id="3-4-4-用-EXPLAIN-分析执行计划"><a href="#3-4-4-用-EXPLAIN-分析执行计划" class="headerlink" title="3.4.4 用 EXPLAIN 分析执行计划"></a>3.4.4 用 EXPLAIN 分析执行计划</h4><p><code>EXPLAIN</code>是 MySQL 的 “调试工具”，能显示 SQL 的执行过程（如是否用索引、是否全表扫描），帮助定位问题。示例：分析四表联查的执行计划：</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">SELECT u.name, o.order_no, p.name </span><br><span class="line">FROM user u</span><br><span class="line">LEFT JOIN order o ON u.id = o.user_id</span><br><span class="line">LEFT JOIN order_product op ON o.id = op.order_id</span><br><span class="line">LEFT JOIN product p ON op.product_id = p.id</span><br><span class="line">WHERE u.id = 123;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>执行结果中，重点看<code>type</code>列（访问类型）：</p>
<ul>
<li>理想值：<code>ref</code>（用索引查找）、<code>range</code>（范围查询）；</li>
<li>需优化值：<code>ALL</code>（全表扫描），需检查是否缺少索引或关联条件。</li>
</ul>
<h4 id="3-4-5-拆分复杂联查为多个简单查询"><a href="#3-4-5-拆分复杂联查为多个简单查询" class="headerlink" title="3.4.5 拆分复杂联查为多个简单查询"></a>3.4.5 拆分复杂联查为多个简单查询</h4><p>如果四表联查过于复杂（如包含子查询、聚合函数），可拆分为多个简单查询，用代码逻辑合并结果。比如：</p>
<ol>
<li>先查用户 123 的订单：<code>SELECT id, order_no FROM order WHERE user_id = 123;</code></li>
<li>再查每个订单的商品：<code>SELECT product_id, quantity FROM order_product WHERE order_id IN (1,2);</code>（1、2 是订单 ID）</li>
<li>最后查商品信息：<code>SELECT id, name FROM product WHERE id IN (101,102);</code>（101、102 是商品 ID）</li>
</ol>
<p>这种方式虽然多了几次查询，但每次查询都很简单，总耗时可能比一次复杂联查更短（尤其在高并发场景）。</p>
<h3 id="3-5-四表联查的常见问题与解决方案"><a href="#3-5-四表联查的常见问题与解决方案" class="headerlink" title="3.5 四表联查的常见问题与解决方案"></a>3.5 四表联查的常见问题与解决方案</h3><h4 id="3-5-1-问题-1：数据重复"><a href="#3-5-1-问题-1：数据重复" class="headerlink" title="3.5.1 问题 1：数据重复"></a>3.5.1 问题 1：数据重复</h4><p><strong>现象</strong>：查询结果中出现重复的订单或商品数据。<strong>原因</strong>：多对多关系未处理好（如<code>order</code>和<code>product</code>直接联查，未通过中间表<code>order_product</code>），导致笛卡尔积。<strong>解决方案</strong>：必须通过中间表联查多对多关系，如案例中<code>order</code>→<code>order_product</code>→<code>product</code>，避免直接联查<code>order</code>和<code>product</code>。</p>
<h4 id="3-5-2-问题-2：数据缺失"><a href="#3-5-2-问题-2：数据缺失" class="headerlink" title="3.5.2 问题 2：数据缺失"></a>3.5.2 问题 2：数据缺失</h4><p><strong>现象</strong>：用户有订单，但查询结果中没有显示订单数据。<strong>原因</strong>：用了<code>INNER JOIN</code>（只保留匹配数据），而订单的<code>user_id</code>为 NULL 或与<code>user.id</code>不匹配。<strong>解决方案</strong>：根据业务需求选择<code>LEFT JOIN</code>（保留左表数据），如案例中<code>user LEFT JOIN order</code>，即使订单的<code>user_id</code>无效，也能显示用户信息。</p>
<h4 id="3-5-3-问题-3：NULL-值导致计算错误"><a href="#3-5-3-问题-3：NULL-值导致计算错误" class="headerlink" title="3.5.3 问题 3：NULL 值导致计算错误"></a>3.5.3 问题 3：NULL 值导致计算错误</h4><p><strong>现象</strong>：小计金额（<code>op.unit_price * op.quantity</code>）为 NULL。<strong>原因</strong>：<code>order_product</code>表中没有数据（订单未包含商品），<code>op.unit_price</code>或<code>op.quantity</code>为 NULL，NULL 乘任何数都是 NULL。<strong>解决方案</strong>：用<code>IFNULL</code>函数处理 NULL 值，如<code>IFNULL(op.unit_price, 0) * IFNULL(op.quantity, 0) AS product_subtotal</code>，将 NULL 转为 0，避免计算错误。</p>
<h3 id="3-6-四表联查小结"><a href="#3-6-四表联查小结" class="headerlink" title="3.6 四表联查小结"></a>3.6 四表联查小结</h3><ul>
<li>四表联查是 “多次两表联查”，核心是<code>JOIN</code>关键字和关联条件；</li>
<li>选择合适的<code>JOIN</code>类型（如<code>LEFT JOIN</code>保留左表数据），避免笛卡尔积；</li>
<li>性能优化核心：关联字段加索引、只查需要字段、提前过滤数据；</li>
<li>常见问题：数据重复（未用中间表）、数据缺失（用错 JOIN 类型）、NULL 计算错误（用 IFNULL 处理）。</li>
</ul>
<hr>
<h2 id="四、全文总结：从技术到业务的落地思考"><a href="#四、全文总结：从技术到业务的落地思考" class="headerlink" title="四、全文总结：从技术到业务的落地思考"></a>四、全文总结：从技术到业务的落地思考</h2><p>本文详细讲解了数据库索引、切片与四表联查的原理、实战与优化，这三个技术不是孤立的，而是相辅相成的：</p>
<ul>
<li>索引是 “基础优化”，无论是单表查询还是四表联查，都需要索引支撑；</li>
<li>切片是 “大数据量解决方案”，当表数据量过大时，即使加了索引，也需要切片拆分表；</li>
<li>四表联查是 “复杂业务工具”，用于整合多个表的数据，支撑如订单详情、用户画像等业务场景。</li>
</ul>
<p>在实际开发中，不要盲目使用这些技术：</p>
<ul>
<li>小表（数据量 &lt; 10 万）不需要切片，加索引即可；</li>
<li>简单业务（如查用户信息）不需要多表联查，单表查询更高效；</li>
<li>索引不是越多越好，需平衡查询和写操作的性能。</li>
</ul>
<p>最后，建议大家在项目中多动手实践：用<code>EXPLAIN</code>分析 SQL 执行计划，用分片工具管理大表，用联查实现复杂业务需求。只有将理论转化为实战经验，才能真正掌握这些数据库核心技术。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/23/%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E6%88%98%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E3%80%81%E5%88%87%E7%89%87%E4%B8%8E%E5%9B%9B%E8%A1%A8%E8%81%94%E6%9F%A5%E5%85%A8%E8%A7%A3%E6%9E%90/" data-id="cuidSJJXYu_S5ykeMY5nTQrp7" data-title="从原理到实战：数据库索引、切片与四表联查全解析" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/12/23/%E6%8E%A2%E7%A7%98%E7%BC%96%E8%AF%91%E5%99%A8%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E5%AF%86%E7%A0%81%EF%BC%9A%E4%BB%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%88%B0%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%E7%9A%84%E5%85%A8%E6%99%AF%E5%9B%BE/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          探秘编译器背后的语言密码：从底层实现到技术演进的全景图
        
      </div>
    </a>
  
  
    <a href="/2025/12/23/2025-%E5%B9%B4-10-%E6%9C%88%E7%A7%91%E6%8A%80%E5%89%8D%E6%B2%BF%E5%85%A8%E6%99%AF%EF%BC%9A%E4%BB%8E%E9%87%8F%E5%AD%90%E8%B7%83%E8%BF%81%E5%88%B0%E7%94%9F%E5%91%BD%E9%87%8D%E6%9E%84%E7%9A%84%E6%96%87%E6%98%8E%E6%8B%90%E7%82%B9/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">2025 年 10 月科技前沿全景：从量子跃迁到生命重构的文明拐点</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" rel="tag">代码拉取</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" rel="tag">文章，博客框架，技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" rel="tag">服务器，游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" rel="tag">权限配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" style="font-size: 10px;">代码拉取</a> <a href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">文章，博客框架，技术</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">服务器，游戏</a> <a href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">权限配置</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">十二月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/25/gitLaB%E9%97%AE%E9%A2%98/">gitLaB问题</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/">大模型微调</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E9%87%8C%E9%9D%A2%E7%9A%84%E2%80%98mcp%E2%80%99%E6%8A%80%E6%9C%AF/">计算机技术里面的‘mcp’技术</a>
          </li>
        
          <li>
            <a href="/2025/12/24/2025-8-19/">2025-8-19</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E9%82%A3%E4%BA%9B%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84-%E8%B6%85%E7%BA%A7%E9%BB%84%E9%87%91-bug-%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%AF%A5%E8%AE%B0%E5%8F%96%E7%9A%84%E8%A1%80%E6%B3%AA%E7%BB%8F%E9%AA%8C/">那些在公司工作中遇到的 &#39;超级黄金 bug&#39;：每个程序员都该记取的血泪经验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 little chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>