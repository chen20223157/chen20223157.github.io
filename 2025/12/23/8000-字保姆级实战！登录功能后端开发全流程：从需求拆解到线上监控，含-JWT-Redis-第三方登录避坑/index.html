<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>8000 字保姆级实战！登录功能后端开发全流程：从需求拆解到线上监控，含 JWT/Redis/ 第三方登录避坑 | 欢迎来到chen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、引言：为什么登录功能值得「深耕细作」？很多开发者觉得登录功能就是「校验账号密码 + 返回令牌」，但实际项目中，登录模块的漏洞往往是系统被攻击的重灾区：  2023 年某电商平台因未做暴力破解防护，导致 10 万用户账号被盗；  某 SaaS 系统因 JWT 密钥泄露，被黑客伪造令牌越权访问核心数据；  某 APP 因密码明文存储，引发用户信息泄露风波。   登录功能的核心价值不仅是「身份认证」">
<meta property="og:type" content="article">
<meta property="og:title" content="8000 字保姆级实战！登录功能后端开发全流程：从需求拆解到线上监控，含 JWT&#x2F;Redis&#x2F; 第三方登录避坑">
<meta property="og:url" content="http://example.com/2025/12/23/8000-%E5%AD%97%E4%BF%9D%E5%A7%86%E7%BA%A7%E5%AE%9E%E6%88%98%EF%BC%81%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A8%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%BB%8E%E9%9C%80%E6%B1%82%E6%8B%86%E8%A7%A3%E5%88%B0%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7%EF%BC%8C%E5%90%AB-JWT-Redis-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E9%81%BF%E5%9D%91/index.html">
<meta property="og:site_name" content="欢迎来到chen的博客">
<meta property="og:description" content="一、引言：为什么登录功能值得「深耕细作」？很多开发者觉得登录功能就是「校验账号密码 + 返回令牌」，但实际项目中，登录模块的漏洞往往是系统被攻击的重灾区：  2023 年某电商平台因未做暴力破解防护，导致 10 万用户账号被盗；  某 SaaS 系统因 JWT 密钥泄露，被黑客伪造令牌越权访问核心数据；  某 APP 因密码明文存储，引发用户信息泄露风波。   登录功能的核心价值不仅是「身份认证」">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-23T11:24:21.000Z">
<meta property="article:modified_time" content="2025-12-24T03:12:22.458Z">
<meta property="article:author" content="little chen">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="欢迎来到chen的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">欢迎来到chen的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-8000-字保姆级实战！登录功能后端开发全流程：从需求拆解到线上监控，含-JWT-Redis-第三方登录避坑" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/23/8000-%E5%AD%97%E4%BF%9D%E5%A7%86%E7%BA%A7%E5%AE%9E%E6%88%98%EF%BC%81%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A8%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%BB%8E%E9%9C%80%E6%B1%82%E6%8B%86%E8%A7%A3%E5%88%B0%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7%EF%BC%8C%E5%90%AB-JWT-Redis-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E9%81%BF%E5%9D%91/" class="article-date">
  <time class="dt-published" datetime="2025-12-23T11:24:21.000Z" itemprop="datePublished">2025-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      8000 字保姆级实战！登录功能后端开发全流程：从需求拆解到线上监控，含 JWT/Redis/ 第三方登录避坑
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、引言：为什么登录功能值得「深耕细作」？"><a href="#一、引言：为什么登录功能值得「深耕细作」？" class="headerlink" title="一、引言：为什么登录功能值得「深耕细作」？"></a>一、引言：为什么登录功能值得「深耕细作」？</h3><p>很多开发者觉得登录功能就是「校验账号密码 + 返回令牌」，但实际项目中，登录模块的漏洞往往是系统被攻击的重灾区：</p>
<ul>
<li><p>2023 年某电商平台因未做暴力破解防护，导致 10 万用户账号被盗；</p>
</li>
<li><p>某 SaaS 系统因 JWT 密钥泄露，被黑客伪造令牌越权访问核心数据；</p>
</li>
<li><p>某 APP 因密码明文存储，引发用户信息泄露风波。</p>
</li>
</ul>
<p>登录功能的核心价值不仅是「身份认证」，更是「安全边界控制」—— 它决定了谁能访问系统、能访问哪些资源、访问的有效期如何。本文将基于「分层架构 + 安全第一 + 可扩展」三大原则，从需求分析到监控运维，一步步拆解开发流程，涵盖<strong>基础账号密码登录、验证码登录、第三方登录、安全防护、性能优化</strong>等核心场景。</p>
<h3 id="二、第一步：需求分析-——-不止于「能登录」，更要「好用-安全」"><a href="#二、第一步：需求分析-——-不止于「能登录」，更要「好用-安全」" class="headerlink" title="二、第一步：需求分析 —— 不止于「能登录」，更要「好用 + 安全」"></a>二、第一步：需求分析 —— 不止于「能登录」，更要「好用 + 安全」</h3><p>开发前必须明确需求边界，避免后期频繁返工。登录功能的需求需分为「功能需求」和「非功能需求」，建议结合产品文档与用户场景拆解：</p>
<h4 id="2-1-功能需求拆解（核心-扩展）"><a href="#2-1-功能需求拆解（核心-扩展）" class="headerlink" title="2.1 功能需求拆解（核心 + 扩展）"></a>2.1 功能需求拆解（核心 + 扩展）</h4><table>
<thead>
<tr>
<th>需求类型</th>
<th>具体描述</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>核心需求</td>
<td>账号密码登录（用户名 &#x2F; 手机号 &#x2F; 邮箱均可作为账号）</td>
<td>所有系统基础场景</td>
</tr>
<tr>
<td>核心需求</td>
<td>登录状态保持（「记住我」功能）</td>
<td>PC 端、APP 端长期登录</td>
</tr>
<tr>
<td>扩展需求</td>
<td>短信验证码登录</td>
<td>手机号注册用户、密码忘记场景</td>
</tr>
<tr>
<td>扩展需求</td>
<td>图形验证码（防机器人攻击）</td>
<td>公共接口、高风险登录场景</td>
</tr>
<tr>
<td>扩展需求</td>
<td>第三方登录（微信 &#x2F; QQ&#x2F;GitHub）</td>
<td>降低注册门槛，提升用户体验</td>
</tr>
<tr>
<td>扩展需求</td>
<td>忘记密码（邮箱 &#x2F; 短信重置）</td>
<td>账号找回核心功能</td>
</tr>
<tr>
<td>权限关联</td>
<td>登录后返回用户角色 &#x2F; 权限信息</td>
<td>基于 RBAC 的权限控制场景</td>
</tr>
</tbody></table>
<h4 id="2-2-非功能需求（决定系统健壮性）"><a href="#2-2-非功能需求（决定系统健壮性）" class="headerlink" title="2.2 非功能需求（决定系统健壮性）"></a>2.2 非功能需求（决定系统健壮性）</h4><ul>
<li><p><strong>安全性</strong>：密码加密存储、防暴力破解、防 SQL 注入、防 XSS、HTTPS 传输；</p>
</li>
<li><p><strong>性能</strong>：单接口 QPS 支持 1000+，响应时间≤300ms；</p>
</li>
<li><p><strong>兼容性</strong>：支持多端（PC&#x2F;APP&#x2F;H5）调用，返回格式统一（JSON）；</p>
</li>
<li><p><strong>可扩展性</strong>：支持后续新增认证方式（如生物识别），不修改核心架构；</p>
</li>
<li><p><strong>可用性</strong>：登录接口可用性≥99.9%，缓存降级机制（如 Redis 挂了仍能登录）。</p>
</li>
</ul>
<h4 id="2-3-用户场景细化（避免想当然）"><a href="#2-3-用户场景细化（避免想当然）" class="headerlink" title="2.3 用户场景细化（避免想当然）"></a>2.3 用户场景细化（避免想当然）</h4><ul>
<li><p>场景 1：用户输入错误密码 3 次，提示「账号锁定 15 分钟」；</p>
</li>
<li><p>场景 2：「记住我」勾选后，登录状态保持 7 天，未勾选则保持 2 小时；</p>
</li>
<li><p>场景 3：异地登录时，触发短信验证二次校验；</p>
</li>
<li><p>场景 4：第三方登录用户首次登录，需补全手机号信息后绑定账号。</p>
</li>
</ul>
<h3 id="三、第二步：技术选型-——-适合的才是最好的（附选型逻辑）"><a href="#三、第二步：技术选型-——-适合的才是最好的（附选型逻辑）" class="headerlink" title="三、第二步：技术选型 —— 适合的才是最好的（附选型逻辑）"></a>三、第二步：技术选型 —— 适合的才是最好的（附选型逻辑）</h3><p>技术选型需结合团队技术栈、系统规模和性能要求，避免盲目追求「新技术」。以下是主流技术组合及选型理由：</p>
<h4 id="3-1-核心技术栈（以-Java-生态为例，其他语言可类比）"><a href="#3-1-核心技术栈（以-Java-生态为例，其他语言可类比）" class="headerlink" title="3.1 核心技术栈（以 Java 生态为例，其他语言可类比）"></a>3.1 核心技术栈（以 Java 生态为例，其他语言可类比）</h4><table>
<thead>
<tr>
<th>技术模块</th>
<th>选型方案</th>
<th>选型理由</th>
</tr>
</thead>
<tbody><tr>
<td>开发语言</td>
<td>Java</td>
<td>团队熟悉度高、生态完善、安全类库丰富</td>
</tr>
<tr>
<td>开发框架</td>
<td>Spring Boot 2.x</td>
<td>快速开发、自动配置、集成 Spring Security 便捷</td>
</tr>
<tr>
<td>安全框架</td>
<td>Spring Security + JWT</td>
<td>成熟稳定、支持多种认证方式、无状态令牌适合分布式场景</td>
</tr>
<tr>
<td>数据库</td>
<td>MySQL 8.0</td>
<td>关系型数据库适合存储用户信息，支持事务和索引优化</td>
</tr>
<tr>
<td>缓存</td>
<td>Redis 6.x</td>
<td>存储登录令牌、验证码、限流计数器、黑名单，高性能读写</td>
</tr>
<tr>
<td>密码加密</td>
<td>BCrypt</td>
<td>自带盐值、不可逆加密、自适应哈希（随着硬件升级可调整计算强度）</td>
</tr>
<tr>
<td>验证码</td>
<td>EasyCaptcha（图形）+ 阿里云短信 API（短信）</td>
<td>轻量级、集成简单、支持自定义验证码样式</td>
</tr>
<tr>
<td>第三方登录</td>
<td>JustAuth</td>
<td>一站式集成 10 + 第三方登录（微信 &#x2F; QQ&#x2F;GitHub 等），避免重复造轮子</td>
</tr>
<tr>
<td>接口文档</td>
<td>Swagger&#x2F;knife4j</td>
<td>自动生成接口文档，方便前后端联调</td>
</tr>
</tbody></table>
<h4 id="3-2-关键技术选型对比（避坑指南）"><a href="#3-2-关键技术选型对比（避坑指南）" class="headerlink" title="3.2 关键技术选型对比（避坑指南）"></a>3.2 关键技术选型对比（避坑指南）</h4><ul>
<li><p><strong>Session vs JWT</strong>：</p>
</li>
<li><ul>
<li>Session：基于服务器存储，分布式场景需共享 Session（如 Redis 集群），适合小型单体应用；</li>
</ul>
</li>
<li><ul>
<li>JWT：无状态令牌，服务器不存储会话信息，仅通过密钥验证有效性，适合分布式系统（微服务）；</li>
</ul>
</li>
<li><ul>
<li>结论：微服务架构优先选 JWT，单体应用可选 Session（简单易用）。</li>
</ul>
</li>
<li><p><strong>MD5 vs BCrypt vs Argon2</strong>：</p>
</li>
<li><ul>
<li>MD5：不可逆但易被彩虹表破解，已淘汰（禁止使用）；</li>
</ul>
</li>
<li><ul>
<li>BCrypt：自带盐值、计算强度可调整（默认 10 轮，可增至 12 轮），安全性足够，性能适中；</li>
</ul>
</li>
<li><ul>
<li>Argon2：2015 年密码哈希竞赛冠军，安全性更高，但 Java 生态支持不如 BCrypt 成熟；</li>
</ul>
</li>
<li><ul>
<li>结论：中小系统用 BCrypt，高安全需求（如金融）用 Argon2。</li>
</ul>
</li>
<li><p><strong>本地缓存 vs Redis</strong>：</p>
</li>
<li><ul>
<li>本地缓存（如 Caffeine）：读写快，但分布式场景下缓存不一致；</li>
</ul>
</li>
<li><ul>
<li>Redis：分布式缓存，支持集群，适合存储全局共享数据（令牌、限流计数器）；</li>
</ul>
</li>
<li><ul>
<li>结论：登录模块核心数据（令牌、验证码）必须用 Redis，本地缓存仅作为降级备用。</li>
</ul>
</li>
</ul>
<h3 id="四、第三步：架构设计-——-分层解耦，为扩展留空间"><a href="#四、第三步：架构设计-——-分层解耦，为扩展留空间" class="headerlink" title="四、第三步：架构设计 —— 分层解耦，为扩展留空间"></a>四、第三步：架构设计 —— 分层解耦，为扩展留空间</h3><p>登录功能的架构需遵循「分层设计」原则，避免业务逻辑与安全逻辑耦合，同时预留扩展点（如新增认证方式时无需修改核心代码）。</p>
<h4 id="4-1-整体架构图（文字描述，可直接转化为-Mermaid-图）"><a href="#4-1-整体架构图（文字描述，可直接转化为-Mermaid-图）" class="headerlink" title="4.1 整体架构图（文字描述，可直接转化为 Mermaid 图）"></a>4.1 整体架构图（文字描述，可直接转化为 Mermaid 图）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户请求 → 网关层（API Gateway）→ 控制层（Controller）→ 业务层（Service）→ 数据层（DAO）</span><br><span class="line">↓ ↓ ↓</span><br><span class="line">安全拦截器 认证适配器 缓存/数据库</span><br><span class="line">↓ ↓</span><br><span class="line">JWT校验/限流 多认证方式（账号密码/验证码/第三方）</span><br></pre></td></tr></table></figure>

<h4 id="4-2-核心分层职责（附代码目录结构）"><a href="#4-2-核心分层职责（附代码目录结构）" class="headerlink" title="4.2 核心分层职责（附代码目录结构）"></a>4.2 核心分层职责（附代码目录结构）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">com.example.login</span><br><span class="line">├── controller // 控制层：接收请求，参数校验，返回响应</span><br><span class="line">│ ├── LoginController.java // 登录相关接口</span><br><span class="line">│ ├── CaptchaController.java // 验证码接口</span><br><span class="line">│ └── ThirdPartyLoginController.java // 第三方登录接口</span><br><span class="line">├── service // 业务层：核心业务逻辑</span><br><span class="line">│ ├── impl</span><br><span class="line">│ │ ├── LoginServiceImpl.java // 登录业务实现</span><br><span class="line">│ │ └── CaptchaServiceImpl.java // 验证码业务实现</span><br><span class="line">│ ├── LoginService.java</span><br><span class="line">│ └── CaptchaService.java</span><br><span class="line">├── security // 安全层：认证、授权、加密、限流</span><br><span class="line">│ ├── config // 安全配置（Spring Security配置）</span><br><span class="line">│ │ └── SecurityConfig.java</span><br><span class="line">│ ├── adapter // 认证适配器（多认证方式适配）</span><br><span class="line">│ │ ├── UsernamePasswordAuthAdapter.java</span><br><span class="line">│ │ ├── SmsCodeAuthAdapter.java</span><br><span class="line">│ │ └── ThirdPartyAuthAdapter.java</span><br><span class="line">│ ├── jwt // JWT工具类</span><br><span class="line">│ │ └── JwtUtil.java</span><br><span class="line">│ └── limit // 限流组件</span><br><span class="line">│ └── RateLimitUtil.java</span><br><span class="line">├── mapper // 数据层：数据库操作</span><br><span class="line">│ └── UserMapper.java</span><br><span class="line">├── model // 数据模型</span><br><span class="line">│ ├── entity // 数据库实体</span><br><span class="line">│ │ └── User.java</span><br><span class="line">│ ├── dto // 入参/出参DTO</span><br><span class="line">│ │ ├── LoginRequestDTO.java</span><br><span class="line">│ │ └── LoginResponseDTO.java</span><br><span class="line">│ └── vo // 视图对象</span><br><span class="line">│ └── UserInfoVO.java</span><br><span class="line">├── util // 工具类</span><br><span class="line">│ ├── RedisUtil.java</span><br><span class="line">│ └── PasswordUtil.java</span><br><span class="line">└── exception // 异常处理</span><br><span class="line">├── GlobalExceptionHandler.java</span><br><span class="line">└── BusinessException.java</span><br></pre></td></tr></table></figure>

<h4 id="4-3-核心组件设计（解耦关键）"><a href="#4-3-核心组件设计（解耦关键）" class="headerlink" title="4.3 核心组件设计（解耦关键）"></a>4.3 核心组件设计（解耦关键）</h4><h5 id="4-3-1-认证适配器模式（支持多认证方式扩展）"><a href="#4-3-1-认证适配器模式（支持多认证方式扩展）" class="headerlink" title="4.3.1 认证适配器模式（支持多认证方式扩展）"></a>4.3.1 认证适配器模式（支持多认证方式扩展）</h5><p>问题：如果直接在 Service 中写「账号密码登录」「短信登录」逻辑，会导致代码臃肿（if-else 堆砌），新增「生物识别登录」时需修改原有代码。</p>
<p>解决方案：使用「适配器模式」，定义统一的认证接口，不同认证方式实现各自的适配器，核心 Service 通过接口调用，无需关心具体实现。</p>
<p>核心代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义统一认证接口</span><br><span class="line">public interface AuthAdapter &#123;</span><br><span class="line">// 认证方法：返回认证成功后的用户信息</span><br><span class="line">UserInfoVO authenticate(AuthRequestDTO requestDTO);</span><br><span class="line">// 支持的认证类型（如PASSWORD/SMS/WECHAT）</span><br><span class="line">AuthTypeEnum supportType();</span><br><span class="line">&#125;</span><br><span class="line">// 2. 账号密码认证适配器（实现类）</span><br><span class="line">@Component</span><br><span class="line">public class UsernamePasswordAuthAdapter implements AuthAdapter &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private UserMapper userMapper;</span><br><span class="line">@Autowired</span><br><span class="line">private PasswordUtil passwordUtil;</span><br><span class="line">@Override</span><br><span class="line">public UserInfoVO authenticate(AuthRequestDTO requestDTO) &#123;</span><br><span class="line">// 1. 获取账号密码（用户名/手机号/邮箱）</span><br><span class="line">String account = requestDTO.getAccount();</span><br><span class="line">String password = requestDTO.getPassword();</span><br><span class="line">// 2. 查询用户（支持多账号类型）</span><br><span class="line">User user = userMapper.selectByAccount(account);</span><br><span class="line">if (user == null) &#123;</span><br><span class="line">throw new BusinessException(&quot;用户不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 3. 校验密码（BCrypt解密校验）</span><br><span class="line">if (!passwordUtil.verify(password, user.getPassword())) &#123;</span><br><span class="line">throw new BusinessException(&quot;密码错误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 4. 校验账号状态（是否锁定/禁用）</span><br><span class="line">if (user.getStatus() == 0) &#123;</span><br><span class="line">throw new BusinessException(&quot;账号已被禁用，请联系管理员&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 5. 返回用户信息（脱敏，不含密码）</span><br><span class="line">return convertToUserInfoVO(user);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public AuthTypeEnum supportType() &#123;</span><br><span class="line">return AuthTypeEnum.PASSWORD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 3. 短信验证码认证适配器（实现类）</span><br><span class="line">@Component</span><br><span class="line">public class SmsCodeAuthAdapter implements AuthAdapter &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private UserMapper userMapper;</span><br><span class="line">@Autowired</span><br><span class="line">private RedisUtil redisUtil;</span><br><span class="line">@Override</span><br><span class="line">public UserInfoVO authenticate(AuthRequestDTO requestDTO) &#123;</span><br><span class="line">String phone = requestDTO.getPhone();</span><br><span class="line">String code = requestDTO.getSmsCode();</span><br><span class="line">// 1. 校验验证码（从Redis获取）</span><br><span class="line">String redisCode = redisUtil.get(&quot;sms_code:&quot; + phone);</span><br><span class="line">if (redisCode == null || !redisCode.equals(code)) &#123;</span><br><span class="line">throw new BusinessException(&quot;验证码错误或已过期&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 2. 查询用户</span><br><span class="line">User user = userMapper.selectByPhone(phone);</span><br><span class="line">if (user == null) &#123;</span><br><span class="line">throw new BusinessException(&quot;该手机号未注册&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 3. 校验账号状态</span><br><span class="line">if (user.getStatus() == 0) &#123;</span><br><span class="line">throw new BusinessException(&quot;账号已被禁用&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 4. 删除Redis中的验证码（防止重复使用）</span><br><span class="line">redisUtil.delete(&quot;sms_code:&quot; + phone);</span><br><span class="line">return convertToUserInfoVO(user);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public AuthTypeEnum supportType() &#123;</span><br><span class="line">return AuthTypeEnum.SMS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 4. 核心Service中调用适配器（通过Spring上下文获取对应适配器）</span><br><span class="line">@Service</span><br><span class="line">public class LoginServiceImpl implements LoginService &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private List&lt;AuthAdapter&gt; authAdapterList; // Spring自动注入所有AuthAdapter实现类</span><br><span class="line">@Override</span><br><span class="line">public UserInfoVO login(AuthRequestDTO requestDTO) &#123;</span><br><span class="line">// 根据认证类型获取对应的适配器</span><br><span class="line">AuthAdapter adapter = authAdapterList.stream()</span><br><span class="line">.filter(a -&gt; a.supportType() == requestDTO.getAuthType())</span><br><span class="line">.findFirst()</span><br><span class="line">.orElseThrow(() -&gt; new BusinessException(&quot;不支持的认证方式&quot;));</span><br><span class="line">// 调用适配器的认证方法</span><br><span class="line">return adapter.authenticate(requestDTO);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-缓存架构设计（性能-可用性双保障）"><a href="#4-3-2-缓存架构设计（性能-可用性双保障）" class="headerlink" title="4.3.2 缓存架构设计（性能 + 可用性双保障）"></a>4.3.2 缓存架构设计（性能 + 可用性双保障）</h5><p>登录模块的缓存核心是「减少数据库查询」和「存储临时数据」，需设计合理的 Key 结构和过期策略：</p>
<table>
<thead>
<tr>
<th>缓存 Key</th>
<th>存储内容</th>
<th>过期时间</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>sms_code:{phone}</td>
<td>短信验证码</td>
<td>5 分钟</td>
<td>验证码校验，防止重复使用</td>
</tr>
<tr>
<td>captcha:{uuid}</td>
<td>图形验证码</td>
<td>2 分钟</td>
<td>防机器人登录</td>
</tr>
<tr>
<td>login_token:{token}</td>
<td>用户信息（脱敏）</td>
<td>与 JWT 令牌过期时间一致</td>
<td>快速获取登录用户信息，避免解析 JWT</td>
</tr>
<tr>
<td>login_blacklist:{token}</td>
<td>令牌黑名单</td>
<td>JWT 过期时间 + 1 小时</td>
<td>处理令牌注销（退出登录）</td>
</tr>
<tr>
<td>login_limit:{ip}</td>
<td>登录失败计数器</td>
<td>15 分钟</td>
<td>防暴力破解（IP 维度限流）</td>
</tr>
<tr>
<td>login_account_limit:{account}</td>
<td>登录失败计数器</td>
<td>15 分钟</td>
<td>防暴力破解（账号维度限流）</td>
</tr>
</tbody></table>
<p>缓存降级策略：当 Redis 挂了，登录模块仍能正常工作（核心流程不依赖缓存）：</p>
<ul>
<li><p>图形验证码：降级为「固定验证码」（仅应急，需及时恢复 Redis）；</p>
</li>
<li><p>限流：降级为「数据库存储计数器」（性能会下降，但保证功能可用）；</p>
</li>
<li><p>令牌信息：直接解析 JWT 令牌（无需缓存查询，仅增加少量 CPU 开销）。</p>
</li>
</ul>
<h3 id="五、第四步：核心模块开发-——-从代码到实战（附完整示例）"><a href="#五、第四步：核心模块开发-——-从代码到实战（附完整示例）" class="headerlink" title="五、第四步：核心模块开发 —— 从代码到实战（附完整示例）"></a>五、第四步：核心模块开发 —— 从代码到实战（附完整示例）</h3><p>本节将聚焦「账号密码登录」「JWT 令牌生成」「安全防护」三大核心模块，提供可直接复用的代码，并讲解关键细节。</p>
<h4 id="5-1-数据库设计（用户表-索引优化）"><a href="#5-1-数据库设计（用户表-索引优化）" class="headerlink" title="5.1 数据库设计（用户表 + 索引优化）"></a>5.1 数据库设计（用户表 + 索引优化）</h4><p>用户表是登录功能的核心数据存储，需兼顾安全性和查询性能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 用户表（t_user）</span><br><span class="line">CREATE TABLE `t_user` (</span><br><span class="line">`id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;用户ID&#x27;,</span><br><span class="line">`username` varchar(50) NOT NULL COMMENT &#x27;用户名（唯一）&#x27;,</span><br><span class="line">`phone` varchar(20) DEFAULT NULL COMMENT &#x27;手机号（唯一）&#x27;,</span><br><span class="line">`email` varchar(100) DEFAULT NULL COMMENT &#x27;邮箱（唯一）&#x27;,</span><br><span class="line">`password` varchar(100) NOT NULL COMMENT &#x27;加密后的密码（BCrypt）&#x27;,</span><br><span class="line">`nickname` varchar(50) DEFAULT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">`avatar` varchar(255) DEFAULT NULL COMMENT &#x27;头像URL&#x27;,</span><br><span class="line">`status` tinyint NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;状态：1-正常，0-禁用&#x27;,</span><br><span class="line">`login_fail_count` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;登录失败次数&#x27;,</span><br><span class="line">`last_login_ip` varchar(50) DEFAULT NULL COMMENT &#x27;最后登录IP&#x27;,</span><br><span class="line">`last_login_time` datetime DEFAULT NULL COMMENT &#x27;最后登录时间&#x27;,</span><br><span class="line">`create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uk_username` (`username`),</span><br><span class="line">UNIQUE KEY `uk_phone` (`phone`),</span><br><span class="line">UNIQUE KEY `uk_email` (`email`),</span><br><span class="line">KEY `idx_login_account` (`username`,`phone`,`email`) COMMENT &#x27;支持多账号类型查询&#x27;</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>设计要点</strong>：</p>
<ul>
<li><p>密码字段长度≥100（BCrypt 加密后长度固定为 60，预留扩展空间）；</p>
</li>
<li><p>三个唯一索引（username&#x2F;phone&#x2F;email），确保账号唯一性；</p>
</li>
<li><p>联合索引idx_login_account：支持「输入任意账号类型（用户名 &#x2F; 手机号 &#x2F; 邮箱）」快速查询；</p>
</li>
<li><p>存储「登录失败次数」：用于触发账号锁定逻辑。</p>
</li>
</ul>
<h4 id="5-2-密码加密工具类（BCrypt-实现）"><a href="#5-2-密码加密工具类（BCrypt-实现）" class="headerlink" title="5.2 密码加密工具类（BCrypt 实现）"></a>5.2 密码加密工具类（BCrypt 实现）</h4><p>密码绝对不能明文存储，BCrypt 是目前最推荐的加密方式（自带盐值，无需额外存储盐）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class PasswordUtil &#123;</span><br><span class="line">private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12); // 计算强度12（越高越安全，性能略降）</span><br><span class="line">/**</span><br><span class="line">* 密码加密（注册/修改密码时使用）</span><br><span class="line">*/</span><br><span class="line">public String encrypt(String rawPassword) &#123;</span><br><span class="line">return encoder.encode(rawPassword);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 密码校验（登录时使用）</span><br><span class="line">* @param rawPassword 用户输入的明文密码</span><br><span class="line">* @param encodedPassword 数据库中存储的加密密码</span><br><span class="line">* @return 是否匹配</span><br><span class="line">*/</span><br><span class="line">public boolean verify(String rawPassword, String encodedPassword) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">return encoder.matches(rawPassword, encodedPassword);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// 异常处理（如加密字符串格式错误）</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong>：</p>
<ul>
<li><p>注册用户时：user.setPassword(passwordUtil.encrypt(rawPassword));</p>
</li>
<li><p>登录校验时：passwordUtil.verify(inputPassword, user.getPassword())</p>
</li>
</ul>
<h4 id="5-3-JWT-工具类（生成-校验-解析）"><a href="#5-3-JWT-工具类（生成-校验-解析）" class="headerlink" title="5.3 JWT 工具类（生成 + 校验 + 解析）"></a>5.3 JWT 工具类（生成 + 校验 + 解析）</h4><p>JWT（JSON Web Token）由「头部（Header）+ 载荷（Payload）+ 签名（Signature）」三部分组成，核心是通过密钥保证令牌不被篡改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import io.jsonwebtoken.Claims;</span><br><span class="line">import io.jsonwebtoken.Jwts;</span><br><span class="line">import io.jsonwebtoken.security.Keys;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import javax.crypto.SecretKey;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">@Component</span><br><span class="line">public class JwtUtil &#123;</span><br><span class="line">// 密钥（生产环境需放在配置中心，禁止硬编码！）</span><br><span class="line">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br><span class="line">private String secret;</span><br><span class="line">// 普通令牌过期时间（2小时）</span><br><span class="line">@Value(&quot;$&#123;jwt.expire.hour&#125;&quot;)</span><br><span class="line">private int expireHour;</span><br><span class="line">// 记住我令牌过期时间（7天）</span><br><span class="line">@Value(&quot;$&#123;jwt.expire.remember-me-hour&#125;&quot;)</span><br><span class="line">private int rememberMeExpireHour;</span><br><span class="line">/**</span><br><span class="line">* 生成JWT令牌</span><br><span class="line">* @param userId 用户ID</span><br><span class="line">* @param username 用户名</span><br><span class="line">* @param roles 角色列表（如[&quot;ADMIN&quot;,&quot;USER&quot;]）</span><br><span class="line">* @param rememberMe 是否记住我</span><br><span class="line">* @return JWT令牌</span><br><span class="line">*/</span><br><span class="line">public String generateToken(Long userId, String username, String[] roles, boolean rememberMe) &#123;</span><br><span class="line">// 1. 设置过期时间</span><br><span class="line">long expireMillis = rememberMe ? </span><br><span class="line">System.currentTimeMillis() + (rememberMeExpireHour * 60 * 60 * 1000) :</span><br><span class="line">System.currentTimeMillis() + (expireHour * 60 * 60 * 1000);</span><br><span class="line">Date expireDate = new Date(expireMillis);</span><br><span class="line">// 2. 设置载荷（Payload）：存储非敏感用户信息</span><br><span class="line">Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();</span><br><span class="line">claims.put(&quot;userId&quot;, userId);</span><br><span class="line">claims.put(&quot;username&quot;, username);</span><br><span class="line">claims.put(&quot;roles&quot;, roles);</span><br><span class="line">// 3. 生成令牌（HS256算法，密钥需足够长≥256位）</span><br><span class="line">SecretKey key = Keys.hmacShaKeyFor(secret.getBytes());</span><br><span class="line">return Jwts.builder()</span><br><span class="line">.setClaims(claims) // 载荷</span><br><span class="line">.setExpiration(expireDate) // 过期时间</span><br><span class="line">.signWith(key) // 签名（密钥+算法）</span><br><span class="line">.compact();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 解析JWT令牌，获取载荷信息</span><br><span class="line">* @param token JWT令牌</span><br><span class="line">* @return 载荷Claims</span><br><span class="line">*/</span><br><span class="line">public Claims parseToken(String token) &#123;</span><br><span class="line">SecretKey key = Keys.hmacShaKeyFor(secret.getBytes());</span><br><span class="line">return Jwts.parserBuilder()</span><br><span class="line">.setSigningKey(key) // 验证密钥</span><br><span class="line">.build()</span><br><span class="line">.parseClaimsJws(token)</span><br><span class="line">.getBody();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 校验令牌是否过期</span><br><span class="line">* @param token JWT令牌</span><br><span class="line">* @return 是否过期</span><br><span class="line">*/</span><br><span class="line">public boolean isTokenExpired(String token) &#123;</span><br><span class="line">Claims claims = parseToken(token);</span><br><span class="line">return claims.getExpiration().before(new Date());</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 从令牌中获取用户ID</span><br><span class="line">*/</span><br><span class="line">public Long getUserIdFromToken(String token) &#123;</span><br><span class="line">Claims claims = parseToken(token);</span><br><span class="line">return claims.get(&quot;userId&quot;, Long.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件（application.yml）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jwt:</span><br><span class="line">secret: 8f8a9d9e-7b6c-4d3e-8a7b-9c8d7e6f5a4b3c2d1e0f1a2b3c4d5e6f7a8b9c0d # 生产环境用32位以上随机字符串（可通过UUID生成）</span><br><span class="line">expire:</span><br><span class="line">hour: 2 # 普通登录过期时间（2小时）</span><br><span class="line">remember-me-hour: 168 # 记住我过期时间（7天）</span><br></pre></td></tr></table></figure>

<p><strong>关键注意事项</strong>：</p>
<ul>
<li><p>密钥（secret）必须足够长（≥256 位），生产环境需通过配置中心（如 Nacos&#x2F;Apollo）管理，禁止硬编码到代码；</p>
</li>
<li><p>载荷（Payload）中<strong>不能存储敏感信息</strong>（如密码、手机号），仅存储非敏感信息（用户 ID、用户名、角色）；</p>
</li>
<li><p>令牌过期时间不宜过长（普通登录 2 小时，记住我 7 天），避免令牌泄露后风险扩大。</p>
</li>
</ul>
<h4 id="5-4-控制层接口（登录-退出-刷新令牌）"><a href="#5-4-控制层接口（登录-退出-刷新令牌）" class="headerlink" title="5.4 控制层接口（登录 + 退出 + 刷新令牌）"></a>5.4 控制层接口（登录 + 退出 + 刷新令牌）</h4><p>控制层负责接收前端请求，参数校验，调用业务层，返回统一响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import com.example.login.model.dto.AuthRequestDTO;</span><br><span class="line">import com.example.login.model.dto.RefreshTokenRequestDTO;</span><br><span class="line">import com.example.login.model.vo.LoginResponseVO;</span><br><span class="line">import com.example.login.model.vo.ResultVO;</span><br><span class="line">import com.example.login.model.vo.UserInfoVO;</span><br><span class="line">import com.example.login.service.LoginService;</span><br><span class="line">import com.example.login.service.TokenService;</span><br><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.validation.annotation.Validated;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/v1/auth&quot;)</span><br><span class="line">@Api(tags = &quot;登录认证接口&quot;)</span><br><span class="line">public class LoginController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private LoginService loginService;</span><br><span class="line">@Autowired</span><br><span class="line">private TokenService tokenService;</span><br><span class="line">/**</span><br><span class="line">* 账号密码/短信验证码登录</span><br><span class="line">*/</span><br><span class="line">@PostMapping(&quot;/login&quot;)</span><br><span class="line">@ApiOperation(&quot;登录接口&quot;)</span><br><span class="line">public ResultVO&lt;LoginResponseVO&gt; login(@Validated @RequestBody AuthRequestDTO requestDTO) &#123;</span><br><span class="line">// 1. 调用业务层进行认证（适配多认证方式）</span><br><span class="line">UserInfoVO userInfo = loginService.login(requestDTO);</span><br><span class="line">// 2. 生成JWT令牌</span><br><span class="line">String token = tokenService.generateToken(userInfo, requestDTO.isRememberMe());</span><br><span class="line">// 3. 将令牌和用户信息存入缓存（Redis）</span><br><span class="line">tokenService.saveTokenToCache(token, userInfo);</span><br><span class="line">// 4. 返回结果（令牌+用户信息）</span><br><span class="line">LoginResponseVO response = new LoginResponseVO();</span><br><span class="line">response.setToken(token);</span><br><span class="line">response.setUserInfo(userInfo);</span><br><span class="line">return ResultVO.success(response);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 退出登录（将令牌加入黑名单）</span><br><span class="line">*/</span><br><span class="line">@PostMapping(&quot;/logout&quot;)</span><br><span class="line">@ApiOperation(&quot;退出登录接口&quot;)</span><br><span class="line">public ResultVO&lt;Void&gt; logout(HttpServletRequest request) &#123;</span><br><span class="line">// 1. 从请求头获取令牌</span><br><span class="line">String token = request.getHeader(&quot;Authorization&quot;).replace(&quot;Bearer &quot;, &quot;&quot;);</span><br><span class="line">// 2. 将令牌加入黑名单（Redis）</span><br><span class="line">tokenService.addTokenToBlacklist(token);</span><br><span class="line">// 3. 删除缓存中的令牌信息</span><br><span class="line">tokenService.removeTokenFromCache(token);</span><br><span class="line">return ResultVO.success();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 刷新令牌（避免用户频繁登录）</span><br><span class="line">*/</span><br><span class="line">@PostMapping(&quot;/refresh-token&quot;)</span><br><span class="line">@ApiOperation(&quot;刷新令牌接口&quot;)</span><br><span class="line">public ResultVO&lt;LoginResponseVO&gt; refreshToken(@Validated @RequestBody RefreshTokenRequestDTO requestDTO) &#123;</span><br><span class="line">// 1. 校验旧令牌有效性</span><br><span class="line">String oldToken = requestDTO.getOldToken();</span><br><span class="line">if (!tokenService.validateToken(oldToken)) &#123;</span><br><span class="line">return ResultVO.error(&quot;旧令牌无效或已过期&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 2. 从旧令牌解析用户信息</span><br><span class="line">UserInfoVO userInfo = tokenService.getUserInfoFromToken(oldToken);</span><br><span class="line">// 3. 生成新令牌</span><br><span class="line">String newToken = tokenService.generateToken(userInfo, requestDTO.isRememberMe());</span><br><span class="line">// 4. 将旧令牌加入黑名单，新令牌存入缓存</span><br><span class="line">tokenService.addTokenToBlacklist(oldToken);</span><br><span class="line">tokenService.saveTokenToCache(newToken, userInfo);</span><br><span class="line">// 5. 返回新令牌</span><br><span class="line">LoginResponseVO response = new LoginResponseVO();</span><br><span class="line">response.setToken(newToken);</span><br><span class="line">response.setUserInfo(userInfo);</span><br><span class="line">return ResultVO.success(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数校验 DTO 示例（AuthRequestDTO）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import com.example.login.enums.AuthTypeEnum;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.hibernate.validator.constraints.Length;</span><br><span class="line">import javax.validation.constraints.NotBlank;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraints.Pattern;</span><br><span class="line">@Data</span><br><span class="line">public class AuthRequestDTO &#123;</span><br><span class="line">/**</span><br><span class="line">* 认证类型（PASSWORD/SMS）</span><br><span class="line">*/</span><br><span class="line">@NotNull(message = &quot;认证类型不能为空&quot;)</span><br><span class="line">private AuthTypeEnum authType;</span><br><span class="line">/**</span><br><span class="line">* 账号（用户名/手机号/邮箱，认证类型为PASSWORD时必填）</span><br><span class="line">*/</span><br><span class="line">@Length(min = 3, max = 50, message = &quot;账号长度为3-50位&quot;)</span><br><span class="line">private String account;</span><br><span class="line">/**</span><br><span class="line">* 密码（认证类型为PASSWORD时必填）</span><br><span class="line">*/</span><br><span class="line">@Length(min = 6, max = 20, message = &quot;密码长度为6-20位&quot;)</span><br><span class="line">private String password;</span><br><span class="line">/**</span><br><span class="line">* 手机号（认证类型为SMS时必填）</span><br><span class="line">*/</span><br><span class="line">@Pattern(regexp = &quot;^1[3-9]\\d&#123;9&#125;$&quot;, message = &quot;手机号格式不正确&quot;)</span><br><span class="line">private String phone;</span><br><span class="line">/**</span><br><span class="line">* 短信验证码（认证类型为SMS时必填）</span><br><span class="line">*/</span><br><span class="line">@Pattern(regexp = &quot;^\\d&#123;6&#125;$&quot;, message = &quot;短信验证码为6位数字&quot;)</span><br><span class="line">private String smsCode;</span><br><span class="line">/**</span><br><span class="line">* 是否记住我</span><br><span class="line">*/</span><br><span class="line">private boolean rememberMe = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-安全防护模块（重中之重，避免漏洞）"><a href="#5-5-安全防护模块（重中之重，避免漏洞）" class="headerlink" title="5.5 安全防护模块（重中之重，避免漏洞）"></a>5.5 安全防护模块（重中之重，避免漏洞）</h4><p>登录功能是黑客攻击的重点目标，必须做好全方位防护，以下是核心防护措施及实现：</p>
<h5 id="5-5-1-防暴力破解（限流-账号锁定）"><a href="#5-5-1-防暴力破解（限流-账号锁定）" class="headerlink" title="5.5.1 防暴力破解（限流 + 账号锁定）"></a>5.5.1 防暴力破解（限流 + 账号锁定）</h5><p><strong>攻击场景</strong>：黑客通过脚本批量尝试账号密码，可能破解弱密码账号。</p>
<p><strong>防护方案</strong>：</p>
<ol>
<li><p>IP 维度限流：同一 IP 15 分钟内最多允许 10 次登录失败；</p>
</li>
<li><p>账号维度限流：同一账号 15 分钟内最多允许 5 次登录失败，超过则锁定 15 分钟；</p>
</li>
<li><p>限流计数器用 Redis 存储，支持分布式场景。</p>
</li>
</ol>
<p><strong>核心代码（RateLimitUtil.java）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import com.example.login.exception.BusinessException;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line">import org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">@Component</span><br><span class="line">public class RateLimitUtil &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">// Lua脚本：原子性操作（避免并发问题）</span><br><span class="line">private static final String RATE_LIMIT_SCRIPT = &quot;&quot;&quot;</span><br><span class="line">local key = KEYS[1]</span><br><span class="line">local maxCount = tonumber(ARGV[1])</span><br><span class="line">local expireTime = tonumber(ARGV[2])</span><br><span class="line">-- 获取当前计数器</span><br><span class="line">local currentCount = redis.call(&#x27;get&#x27;, key)</span><br><span class="line">if currentCount == nil then</span><br><span class="line">-- 第一次访问，初始化计数器</span><br><span class="line">redis.call(&#x27;set&#x27;, key, 1, &#x27;EX&#x27;, expireTime)</span><br><span class="line">return 1</span><br><span class="line">end</span><br><span class="line">-- 计数器+1</span><br><span class="line">currentCount = tonumber(currentCount) + 1</span><br><span class="line">if currentCount &gt; maxCount then</span><br><span class="line">-- 超过限制，返回0</span><br><span class="line">return 0</span><br><span class="line">end</span><br><span class="line">-- 更新计数器</span><br><span class="line">redis.call(&#x27;set&#x27;, key, currentCount, &#x27;EX&#x27;, expireTime)</span><br><span class="line">return currentCount</span><br><span class="line">&quot;&quot;&quot;;</span><br><span class="line">/**</span><br><span class="line">* 登录限流（IP维度）</span><br><span class="line">* @param ip 用户IP</span><br><span class="line">* @return 是否允许登录</span><br><span class="line">*/</span><br><span class="line">public boolean limitByIp(String ip) &#123;</span><br><span class="line">String key = &quot;login_limit:ip:&quot; + ip;</span><br><span class="line">int maxCount = 10; // 15分钟内最多10次失败</span><br><span class="line">int expireTime = 15 * 60; // 15分钟</span><br><span class="line">return executeLimitScript(key, maxCount, expireTime);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 登录限流（账号维度）</span><br><span class="line">* @param account 账号</span><br><span class="line">* @return 是否允许登录</span><br><span class="line">*/</span><br><span class="line">public boolean limitByAccount(String account) &#123;</span><br><span class="line">String key = &quot;login_limit:account:&quot; + account;</span><br><span class="line">int maxCount = 5; // 15分钟内最多5次失败</span><br><span class="line">int expireTime = 15 * 60; // 15分钟</span><br><span class="line">return executeLimitScript(key, maxCount, expireTime);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 执行限流Lua脚本</span><br><span class="line">*/</span><br><span class="line">private boolean executeLimitScript(String key, int maxCount, int expireTime) &#123;</span><br><span class="line">DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;();</span><br><span class="line">script.setScriptText(RATE_LIMIT_SCRIPT);</span><br><span class="line">script.setResultType(Long.class);</span><br><span class="line">Long result = redisTemplate.execute(</span><br><span class="line">script,</span><br><span class="line">Collections.singletonList(key),</span><br><span class="line">String.valueOf(maxCount),</span><br><span class="line">String.valueOf(expireTime)</span><br><span class="line">);</span><br><span class="line">return result != null &amp;&amp; result &lt;= maxCount;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 登录成功后，重置限流计数器</span><br><span class="line">*/</span><br><span class="line">public void resetLimit(String ip, String account) &#123;</span><br><span class="line">redisTemplate.delete(&quot;login_limit:ip:&quot; + ip);</span><br><span class="line">redisTemplate.delete(&quot;login_limit:account:&quot; + account);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景（LoginServiceImpl.java 中添加）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public UserInfoVO login(AuthRequestDTO requestDTO) &#123;</span><br><span class="line">String ip = RequestContextHolder.getRequestAttributes().getRemoteAddress(); // 获取用户IP</span><br><span class="line">String account = requestDTO.getAuthType() == AuthTypeEnum.PASSWORD ? requestDTO.getAccount() : requestDTO.getPhone();</span><br><span class="line">// 1. 限流校验</span><br><span class="line">boolean ipLimitPass = rateLimitUtil.limitByIp(ip);</span><br><span class="line">boolean accountLimitPass = rateLimitUtil.limitByAccount(account);</span><br><span class="line">if (!ipLimitPass) &#123;</span><br><span class="line">throw new BusinessException(&quot;当前IP登录失败次数过多，请15分钟后再试&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (!accountLimitPass) &#123;</span><br><span class="line">throw new BusinessException(&quot;当前账号登录失败次数过多，已锁定15分钟&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 2. 调用适配器认证（原有逻辑）</span><br><span class="line">AuthAdapter adapter = getAuthAdapter(requestDTO.getAuthType());</span><br><span class="line">UserInfoVO userInfo = null;</span><br><span class="line">try &#123;</span><br><span class="line">userInfo = adapter.authenticate(requestDTO);</span><br><span class="line">// 3. 登录成功，重置限流计数器</span><br><span class="line">rateLimitUtil.resetLimit(ip, account);</span><br><span class="line">&#125; catch (BusinessException e) &#123;</span><br><span class="line">// 登录失败，不重置计数器（限流继续生效）</span><br><span class="line">throw e;</span><br><span class="line">&#125;</span><br><span class="line">return userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-2-防-SQL-注入（参数化查询-ORM-框架）"><a href="#5-5-2-防-SQL-注入（参数化查询-ORM-框架）" class="headerlink" title="5.5.2 防 SQL 注入（参数化查询 + ORM 框架）"></a>5.5.2 防 SQL 注入（参数化查询 + ORM 框架）</h5><p><strong>攻击场景</strong>：黑客在账号输入框输入’ or 1&#x3D;1 –，尝试绕过账号密码校验。</p>
<p><strong>防护方案</strong>：</p>
<ol>
<li><p>使用 MyBatis 的参数化查询（#{}, 而非${}）；</p>
</li>
<li><p>避免直接拼接 SQL 语句；</p>
</li>
<li><p>对用户输入进行过滤（如过滤单引号、分号等特殊字符）。</p>
</li>
</ol>
<p><strong>错误示例（禁止使用）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 错误：使用$&#123;&#125;拼接SQL，存在注入风险 --&gt;</span><br><span class="line">&lt;select id=&quot;selectByAccount&quot; resultType=&quot;com.example.login.model.entity.User&quot;&gt;</span><br><span class="line">select * from t_user where username = &#x27;$&#123;account&#125;&#x27; or phone = &#x27;$&#123;account&#125;&#x27; or email = &#x27;$&#123;account&#125;&#x27;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p><strong>正确示例（参数化查询）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正确：使用#&#123;&#125;参数化查询，MyBatis自动转义 --&gt;</span><br><span class="line">&lt;select id=&quot;selectByAccount&quot; resultType=&quot;com.example.login.model.entity.User&quot;&gt;</span><br><span class="line">select * from t_user </span><br><span class="line">where username = #&#123;account&#125; </span><br><span class="line">or phone = #&#123;account&#125; </span><br><span class="line">or email = #&#123;account&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-3-防-XSS-攻击（输入过滤-响应编码）"><a href="#5-5-3-防-XSS-攻击（输入过滤-响应编码）" class="headerlink" title="5.5.3 防 XSS 攻击（输入过滤 + 响应编码）"></a>5.5.3 防 XSS 攻击（输入过滤 + 响应编码）</h5><p><strong>攻击场景</strong>：黑客在账号输入框输入<script>alert(&#39;xss&#39;)</script>，若后端未过滤，可能导致前端页面执行恶意脚本。</p>
<p><strong>防护方案</strong>：</p>
<ol>
<li><p>对用户输入的字符串进行 HTML 转义（如&lt;转义为&lt;）；</p>
</li>
<li><p>使用 Spring Security 的 XSS 过滤器；</p>
</li>
<li><p>前端响应时设置Content-Security-Policy头，限制脚本执行。</p>
</li>
</ol>
<p><strong>核心代码（XssFilter.java）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">@Component</span><br><span class="line">public class XssFilter implements Filter &#123;</span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">// 包装请求，对输入进行XSS过滤</span><br><span class="line">XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest) request);</span><br><span class="line">chain.doFilter(xssRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// XSS请求包装类</span><br><span class="line">class XssHttpServletRequestWrapper extends javax.servlet.http.HttpServletRequestWrapper &#123;</span><br><span class="line">public XssHttpServletRequestWrapper(HttpServletRequest request) &#123;</span><br><span class="line">super(request);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String getParameter(String name) &#123;</span><br><span class="line">String value = super.getParameter(name);</span><br><span class="line">return xssEscape(value);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String[] getParameterValues(String name) &#123;</span><br><span class="line">String[] values = super.getParameterValues(name);</span><br><span class="line">if (values == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">values[i] = xssEscape(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">return values;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* HTML转义</span><br><span class="line">*/</span><br><span class="line">private String xssEscape(String value) &#123;</span><br><span class="line">if (value == null) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">value = value.replaceAll(&quot;&lt;&quot;, &quot;&lt;&quot;)</span><br><span class="line">.replaceAll(&quot;&gt;&quot;, &quot;&gt;&quot;)</span><br><span class="line">.replaceAll(&quot;&#x27;&quot;, &quot;&#x27;&quot;)</span><br><span class="line">.replaceAll(&quot;\&quot;&quot;, &quot;&quot;&quot;)</span><br><span class="line">.replaceAll(&quot;\\(&quot;, &quot;&amp;\#40;&quot;)</span><br><span class="line">.replaceAll(&quot;\\)&quot;, &quot;)&quot;)</span><br><span class="line">.replaceAll(&quot;;&quot;, &quot;;&quot;);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-4-JWT-安全防护（避免令牌泄露-篡改）"><a href="#5-5-4-JWT-安全防护（避免令牌泄露-篡改）" class="headerlink" title="5.5.4 JWT 安全防护（避免令牌泄露 + 篡改）"></a>5.5.4 JWT 安全防护（避免令牌泄露 + 篡改）</h5><p><strong>攻击场景</strong>：黑客窃取 JWT 令牌后，伪造请求访问系统；或篡改令牌中的用户角色（如从 USER 改为 ADMIN）。</p>
<p><strong>防护方案</strong>：</p>
<ol>
<li><p>令牌传输必须使用 HTTPS（防止中间人窃取）；</p>
</li>
<li><p>密钥（secret）定期轮换（如每 3 个月更换一次）；</p>
</li>
<li><p>令牌中加入「签名」，黑客篡改后签名失效；</p>
</li>
<li><p>实现令牌黑名单机制（退出登录时将令牌加入黑名单）；</p>
</li>
<li><p>敏感操作（如转账、修改密码）需二次校验（短信 &#x2F; 验证码）。</p>
</li>
</ol>
<p><strong>令牌黑名单实现（TokenService.java）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 将令牌加入黑名单（退出登录时调用）</span><br><span class="line">*/</span><br><span class="line">public void addTokenToBlacklist(String token) &#123;</span><br><span class="line">// 计算令牌剩余过期时间</span><br><span class="line">Claims claims = jwtUtil.parseToken(token);</span><br><span class="line">long expireMillis = claims.getExpiration().getTime() - System.currentTimeMillis();</span><br><span class="line">if (expireMillis &gt; 0) &#123;</span><br><span class="line">// 黑名单Key：login_blacklist:&#123;token&#125;，过期时间=令牌剩余时间+1小时（避免令牌过期后仍在黑名单）</span><br><span class="line">redisTemplate.opsForValue().set(</span><br><span class="line">&quot;login_blacklist:&quot; + token,</span><br><span class="line">&quot;1&quot;,</span><br><span class="line">expireMillis + 3600000,</span><br><span class="line">TimeUnit.MILLISECONDS</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 校验令牌是否在黑名单中</span><br><span class="line">*/</span><br><span class="line">public boolean isTokenInBlacklist(String token) &#123;</span><br><span class="line">return redisTemplate.hasKey(&quot;login_blacklist:&quot; + token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、第五步：扩展功能开发-——-第三方登录-忘记密码"><a href="#六、第五步：扩展功能开发-——-第三方登录-忘记密码" class="headerlink" title="六、第五步：扩展功能开发 —— 第三方登录 + 忘记密码"></a>六、第五步：扩展功能开发 —— 第三方登录 + 忘记密码</h3><h4 id="6-1-第三方登录（以微信登录为例）"><a href="#6-1-第三方登录（以微信登录为例）" class="headerlink" title="6.1 第三方登录（以微信登录为例）"></a>6.1 第三方登录（以微信登录为例）</h4><p>第三方登录的核心是「OAuth2.0 协议」，通过 JustAuth 框架可快速集成：</p>
<h4 id="6-1-1-依赖引入（pom-xml）"><a href="#6-1-1-依赖引入（pom-xml）" class="headerlink" title="6.1.1 依赖引入（pom.xml）"></a>6.1.1 依赖引入（pom.xml）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- JustAuth核心依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;me.zhyd.oauth&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;JustAuth&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 微信登录依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;me.zhyd.oauth&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;justauth-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-配置文件（application-yml）"><a href="#6-1-2-配置文件（application-yml）" class="headerlink" title="6.1.2 配置文件（application.yml）"></a>6.1.2 配置文件（application.yml）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">justauth:</span><br><span class="line">enabled: true</span><br><span class="line">type:</span><br><span class="line">WECHAT_OPEN:</span><br><span class="line">client-id: 你的微信开放平台AppID</span><br><span class="line">client-secret: 你的微信开放平台AppSecret</span><br><span class="line">redirect-uri: http://localhost:8080/api/v1/auth/third-party/wechat/callback # 回调地址（需在微信开放平台配置）</span><br></pre></td></tr></table></figure>

<h4 id="6-1-3-核心代码（ThirdPartyLoginController-java）"><a href="#6-1-3-核心代码（ThirdPartyLoginController-java）" class="headerlink" title="6.1.3 核心代码（ThirdPartyLoginController.java）"></a>6.1.3 核心代码（ThirdPartyLoginController.java）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">import me.zhyd.oauth.config.AuthConfig;</span><br><span class="line">import me.zhyd.oauth.model.AuthCallback;</span><br><span class="line">import me.zhyd.oauth.model.AuthResponse;</span><br><span class="line">import me.zhyd.oauth.request.AuthWeChatOpenRequest;</span><br><span class="line">import me.zhyd.oauth.utils.AuthStateUtils;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/v1/auth/third-party&quot;)</span><br><span class="line">public class ThirdPartyLoginController &#123;</span><br><span class="line">@Value(&quot;$&#123;justauth.type.WECHAT_OPEN.client-id&#125;&quot;)</span><br><span class="line">private String clientId;</span><br><span class="line">@Value(&quot;$&#123;justauth.type.WECHAT_OPEN.client-secret&#125;&quot;)</span><br><span class="line">private String clientSecret;</span><br><span class="line">@Value(&quot;$&#123;justauth.type.WECHAT_OPEN.redirect-uri&#125;&quot;)</span><br><span class="line">private String redirectUri;</span><br><span class="line">/**</span><br><span class="line">* 微信登录授权（跳转微信登录页面）</span><br><span class="line">*/</span><br><span class="line">@GetMapping(&quot;/wechat/login&quot;)</span><br><span class="line">public void wechatLogin(HttpServletResponse response) throws IOException &#123;</span><br><span class="line">AuthWeChatOpenRequest request = new AuthWeChatOpenRequest(AuthConfig.builder()</span><br><span class="line">.clientId(clientId)</span><br><span class="line">.clientSecret(clientSecret)</span><br><span class="line">.redirectUri(redirectUri)</span><br><span class="line">.build());</span><br><span class="line">// 生成state（防CSRF攻击）</span><br><span class="line">String state = AuthStateUtils.createState();</span><br><span class="line">// 跳转微信授权页面</span><br><span class="line">String authorizeUrl = request.authorize(state);</span><br><span class="line">response.sendRedirect(authorizeUrl);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 微信登录回调（微信授权后跳转至此接口）</span><br><span class="line">*/</span><br><span class="line">@GetMapping(&quot;/wechat/callback&quot;)</span><br><span class="line">public ResultVO&lt;LoginResponseVO&gt; wechatCallback(AuthCallback callback) &#123;</span><br><span class="line">// 1. 调用JustAuth获取微信用户信息</span><br><span class="line">AuthWeChatOpenRequest request = new AuthWeChatOpenRequest(AuthConfig.builder()</span><br><span class="line">.clientId(clientId)</span><br><span class="line">.clientSecret(clientSecret)</span><br><span class="line">.redirectUri(redirectUri)</span><br><span class="line">.build());</span><br><span class="line">AuthResponse&lt;?&gt; authResponse = request.login(callback);</span><br><span class="line">// 2. 处理用户信息（首次登录需绑定手机号，已绑定则直接登录）</span><br><span class="line">if (authResponse.ok()) &#123;</span><br><span class="line">// 获取微信用户唯一标识（openid）</span><br><span class="line">String openid = authResponse.getData().getUuid();</span><br><span class="line">// 查询数据库：是否已绑定本地账号</span><br><span class="line">User user = userMapper.selectByWechatOpenid(openid);</span><br><span class="line">if (user != null) &#123;</span><br><span class="line">// 已绑定，直接生成令牌登录</span><br><span class="line">UserInfoVO userInfo = convertToUserInfoVO(user);</span><br><span class="line">String token = tokenService.generateToken(userInfo, false);</span><br><span class="line">tokenService.saveTokenToCache(token, userInfo);</span><br><span class="line">LoginResponseVO response = new LoginResponseVO();</span><br><span class="line">response.setToken(token);</span><br><span class="line">response.setUserInfo(userInfo);</span><br><span class="line">return ResultVO.success(response);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 未绑定，返回openid，前端引导用户补全手机号并绑定</span><br><span class="line">return ResultVO.success(&quot;未绑定本地账号&quot;, openid);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">throw new BusinessException(&quot;微信登录失败：&quot; + authResponse.getMsg());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 绑定本地账号（补全手机号后调用）</span><br><span class="line">*/</span><br><span class="line">@PostMapping(&quot;/wechat/bind&quot;)</span><br><span class="line">public ResultVO&lt;LoginResponseVO&gt; bindWechat(@RequestParam String openid, @RequestParam String phone, @RequestParam String smsCode) &#123;</span><br><span class="line">// 1. 校验短信验证码（略，同短信登录逻辑）</span><br><span class="line">// 2. 查询本地账号（根据手机号）</span><br><span class="line">User user = userMapper.selectByPhone(phone);</span><br><span class="line">if (user == null) &#123;</span><br><span class="line">// 未注册，自动创建账号（默认密码为空，或引导用户设置密码）</span><br><span class="line">user = createDefaultUser(phone, openid);</span><br><span class="line">userMapper.insert(user);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 已注册，绑定openid</span><br><span class="line">user.setWechatOpenid(openid);</span><br><span class="line">userMapper.updateById(user);</span><br><span class="line">&#125;</span><br><span class="line">// 3. 生成令牌登录</span><br><span class="line">UserInfoVO userInfo = convertToUserInfoVO(user);</span><br><span class="line">String token = tokenService.generateToken(userInfo, false);</span><br><span class="line">tokenService.saveTokenToCache(token, userInfo);</span><br><span class="line">LoginResponseVO response = new LoginResponseVO();</span><br><span class="line">response.setToken(token);</span><br><span class="line">response.setUserInfo(userInfo);</span><br><span class="line">return ResultVO.success(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-忘记密码（短信重置）"><a href="#6-2-忘记密码（短信重置）" class="headerlink" title="6.2 忘记密码（短信重置）"></a>6.2 忘记密码（短信重置）</h4><p>核心流程：「获取短信验证码 → 校验验证码 → 重置密码」</p>
<p><strong>核心代码（PasswordController.java）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import com.example.login.model.dto.SmsCodeRequestDTO;</span><br><span class="line">import com.example.login.model.dto.ResetPasswordRequestDTO;</span><br><span class="line">import com.example.login.model.vo.ResultVO;</span><br><span class="line">import com.example.login.service.CaptchaService;</span><br><span class="line">import com.example.login.service.UserService;</span><br><span class="line">import com.example.login.util.PasswordUtil;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.validation.annotation.Validated;</span><br><span class="line">import org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api/v1/password&quot;)</span><br><span class="line">public class PasswordController &#123;</span><br><span class="line">@Autowired</span><br><span class="line">private CaptchaService captchaService;</span><br><span class="line">@Autowired</span><br><span class="line">private UserService userService;</span><br><span class="line">@Autowired</span><br><span class="line">private PasswordUtil passwordUtil;</span><br><span class="line">/**</span><br><span class="line">* 发送重置密码短信验证码</span><br><span class="line">*/</span><br><span class="line">@PostMapping(&quot;/send-reset-code&quot;)</span><br><span class="line">public ResultVO&lt;Void&gt; sendResetCode(@Validated @RequestBody SmsCodeRequestDTO requestDTO) &#123;</span><br><span class="line">String phone = requestDTO.getPhone();</span><br><span class="line">// 1. 校验手机号是否已注册</span><br><span class="line">boolean exists = userService.checkPhoneExists(phone);</span><br><span class="line">if (!exists) &#123;</span><br><span class="line">throw new BusinessException(&quot;该手机号未注册&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 2. 发送短信验证码（存入Redis，5分钟过期）</span><br><span class="line">captchaService.sendSmsCode(phone, &quot;reset_password&quot;);</span><br><span class="line">return ResultVO.success(&quot;验证码已发送至您的手机&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 重置密码</span><br><span class="line">*/</span><br><span class="line">@PostMapping(&quot;/reset&quot;)</span><br><span class="line">public ResultVO&lt;Void&gt; resetPassword(@Validated @RequestBody ResetPasswordRequestDTO requestDTO) &#123;</span><br><span class="line">String phone = requestDTO.getPhone();</span><br><span class="line">String code = requestDTO.getSmsCode();</span><br><span class="line">String newPassword = requestDTO.getNewPassword();</span><br><span class="line">// 1. 校验短信验证码</span><br><span class="line">boolean valid = captchaService.verifySmsCode(phone, code, &quot;reset_password&quot;);</span><br><span class="line">if (!valid) &#123;</span><br><span class="line">throw new BusinessException(&quot;验证码错误或已过期&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 2. 加密新密码</span><br><span class="line">String encryptedPassword = passwordUtil.encrypt(newPassword);</span><br><span class="line">// 3. 更新数据库密码</span><br><span class="line">userService.updatePasswordByPhone(phone, encryptedPassword);</span><br><span class="line">// 4. 清除该用户所有登录令牌（强制退出所有设备）</span><br><span class="line">userService.invalidateAllTokens(phone);</span><br><span class="line">return ResultVO.success(&quot;密码重置成功，请重新登录&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、第六步：测试-——-确保功能与安全双达标"><a href="#七、第六步：测试-——-确保功能与安全双达标" class="headerlink" title="七、第六步：测试 —— 确保功能与安全双达标"></a>七、第六步：测试 —— 确保功能与安全双达标</h3><p>登录功能的测试需覆盖「功能测试」「安全测试」「性能测试」，避免上线后出现漏洞：</p>
<h4 id="7-1-功能测试（核心用例）"><a href="#7-1-功能测试（核心用例）" class="headerlink" title="7.1 功能测试（核心用例）"></a>7.1 功能测试（核心用例）</h4><table>
<thead>
<tr>
<th>测试用例</th>
<th>预期结果</th>
</tr>
</thead>
<tbody><tr>
<td>输入正确账号密码登录</td>
<td>登录成功，返回令牌和用户信息</td>
</tr>
<tr>
<td>输入错误密码登录 3 次</td>
<td>提示「账号锁定 15 分钟」</td>
</tr>
<tr>
<td>输入正确验证码登录</td>
<td>登录成功，Redis 中验证码被删除</td>
</tr>
<tr>
<td>勾选「记住我」登录</td>
<td>令牌过期时间为 7 天</td>
</tr>
<tr>
<td>退出登录后，使用原令牌访问</td>
<td>提示「令牌已失效」</td>
</tr>
<tr>
<td>第三方登录（微信）首次登录</td>
<td>提示绑定手机号</td>
</tr>
<tr>
<td>忘记密码后重置</td>
<td>密码更新成功，原令牌失效</td>
</tr>
</tbody></table>
<h4 id="7-2-安全测试（工具-方法）"><a href="#7-2-安全测试（工具-方法）" class="headerlink" title="7.2 安全测试（工具 + 方法）"></a>7.2 安全测试（工具 + 方法）</h4><ul>
<li><p><strong>SQL 注入测试</strong>：使用 Burp Suite 拦截登录请求，修改账号参数为’ or 1&#x3D;1 –，预期返回「用户不存在」；</p>
</li>
<li><p><strong>暴力破解测试</strong>：使用 JMeter 模拟 100 次连续登录失败，预期触发 IP &#x2F; 账号限流；</p>
</li>
<li><p><strong>XSS 测试</strong>：账号输入框输入<script>alert(&#39;xss&#39;)</script>，预期后端返回转义后的字符串，前端不执行脚本；</p>
</li>
<li><p><strong>JWT 篡改测试</strong>：修改 JWT 令牌中的roles字段为[“ADMIN”]，预期校验失败；</p>
</li>
<li><p><strong>HTTPS 测试</strong>：使用 HTTP 协议访问登录接口，预期跳转至 HTTPS 或返回 403。</p>
</li>
</ul>
<h4 id="7-3-性能测试（JMeter-压测）"><a href="#7-3-性能测试（JMeter-压测）" class="headerlink" title="7.3 性能测试（JMeter 压测）"></a>7.3 性能测试（JMeter 压测）</h4><ul>
<li><p>测试场景：1000 用户并发登录，持续 10 分钟；</p>
</li>
<li><p>预期指标：响应时间≤300ms，错误率≤0.1%，QPS≥1000；</p>
</li>
<li><p>瓶颈优化：若响应时间过长，检查 Redis 缓存命中率（应≥95%）、数据库索引是否生效。</p>
</li>
</ul>
<h3 id="八、第七步：部署与监控-——-确保稳定运行"><a href="#八、第七步：部署与监控-——-确保稳定运行" class="headerlink" title="八、第七步：部署与监控 —— 确保稳定运行"></a>八、第七步：部署与监控 —— 确保稳定运行</h3><h4 id="8-1-部署注意事项"><a href="#8-1-部署注意事项" class="headerlink" title="8.1 部署注意事项"></a>8.1 部署注意事项</h4><ul>
<li><p><strong>环境隔离</strong>：开发 &#x2F; 测试 &#x2F; 生产环境的 JWT 密钥、Redis 配置、第三方登录 AppID 需分开配置；</p>
</li>
<li><p><strong>密钥管理</strong>：生产环境的 JWT 密钥、数据库密码等敏感信息，使用配置中心（Nacos&#x2F;Apollo）或环境变量存储，禁止硬编码；</p>
</li>
<li><p><strong>Redis 集群</strong>：生产环境使用 Redis 集群（主从 + 哨兵），避免缓存单点故障；</p>
</li>
<li><p><strong>HTTPS 配置</strong>：通过 Nginx 配置 HTTPS，强制所有登录相关接口使用 HTTPS 传输。</p>
</li>
</ul>
<h4 id="8-2-监控告警（核心指标）"><a href="#8-2-监控告警（核心指标）" class="headerlink" title="8.2 监控告警（核心指标）"></a>8.2 监控告警（核心指标）</h4><ul>
<li><p><strong>接口可用性</strong>：监控登录接口的成功率（应≥99.9%），失败时触发邮件 &#x2F; 短信告警；</p>
</li>
<li><p><strong>安全告警</strong>：监控登录失败次数异常（如某 IP 1 分钟内失败 50 次），触发安全告警；</p>
</li>
<li><p><strong>性能监控</strong>：监控接口响应时间、Redis 缓存命中率、数据库查询耗时，超过阈值触发告警；</p>
</li>
<li><p><strong>日志收集</strong>：使用 ELK 收集登录日志（成功 &#x2F; 失败、IP、时间），便于后续审计和问题排查。</p>
</li>
</ul>
<h3 id="九、常见问题与排坑指南（实战经验）"><a href="#九、常见问题与排坑指南（实战经验）" class="headerlink" title="九、常见问题与排坑指南（实战经验）"></a>九、常见问题与排坑指南（实战经验）</h3><h4 id="9-1-JWT-令牌过期后仍能访问？"><a href="#9-1-JWT-令牌过期后仍能访问？" class="headerlink" title="9.1 JWT 令牌过期后仍能访问？"></a>9.1 JWT 令牌过期后仍能访问？</h4><ul>
<li><p>原因：缓存中未删除过期令牌，或黑名单机制未生效；</p>
</li>
<li><p>解决方案：1. 每次请求时校验令牌过期时间；2. 令牌过期后自动从缓存删除；3. 退出登录时强制加入黑名单。</p>
</li>
</ul>
<h4 id="9-2-Redis-挂了，登录功能不可用？"><a href="#9-2-Redis-挂了，登录功能不可用？" class="headerlink" title="9.2 Redis 挂了，登录功能不可用？"></a>9.2 Redis 挂了，登录功能不可用？</h4><ul>
<li><p>原因：核心流程依赖 Redis（如验证码、限流），未做降级；</p>
</li>
<li><p>解决方案：1. 实现 Redis 降级策略（如验证码降级为固定值）；2. 使用 Redis 集群提高可用性；3. 核心数据（用户信息）仍从数据库查询。</p>
</li>
</ul>
<h4 id="9-3-第三方登录回调失败？"><a href="#9-3-第三方登录回调失败？" class="headerlink" title="9.3 第三方登录回调失败？"></a>9.3 第三方登录回调失败？</h4><ul>
<li><p>原因：1. 回调地址未在第三方平台配置；2. state 参数不匹配；3. 网络不通；</p>
</li>
<li><p>解决方案：1. 检查第三方平台回调地址配置；2. 确保 state 参数在授权和回调时一致；3. 排查服务器网络是否能访问第三方平台接口。</p>
</li>
</ul>
<h4 id="9-4-密码加密后无法校验？"><a href="#9-4-密码加密后无法校验？" class="headerlink" title="9.4 密码加密后无法校验？"></a>9.4 密码加密后无法校验？</h4><ul>
<li><p>原因：1. BCrypt 加密时计算强度不一致；2. 密码字符串有空格；3. 加密后的密码存储长度不足；</p>
</li>
<li><p>解决方案：1. 加密和校验时使用相同的计算强度；2. 对用户输入的密码进行 trim 处理；3. 数据库密码字段长度≥100。</p>
</li>
</ul>
<h3 id="十、总结：登录功能的「道」与「术」"><a href="#十、总结：登录功能的「道」与「术」" class="headerlink" title="十、总结：登录功能的「道」与「术」"></a>十、总结：登录功能的「道」与「术」</h3><p>登录功能看似简单，实则是系统安全的「第一道防线」—— 它的开发不仅需要掌握「术」（技术选型、代码实现），更要理解「道」（安全设计、用户体验）。</p>
<p>本文从需求分析到部署监控，完整拆解了登录功能的后端开发流程，核心要点可总结为：</p>
<ol>
<li><p><strong>分层解耦</strong>：使用适配器模式支持多认证方式，便于扩展；</p>
</li>
<li><p><strong>安全第一</strong>：密码加密、限流、防注入、JWT 防护等措施缺一不可；</p>
</li>
<li><p><strong>性能优先</strong>：使用 Redis 缓存减少数据库查询，提高响应速度；</p>
</li>
<li><p><strong>用户体验</strong>：支持第三方登录、记住我、忘记密码等功能，降低用户操作成本。</p>
</li>
</ol>
<p>登录功能的开发没有「银弹」，需结合系统规模、业务场景和安全需求灵活调整 —— 小型单体应用可简化架构（如用 Session 代替 JWT），大型分布式系统则需注重扩展性和分布式一致性。</p>
<p>最后，建议定期对登录功能进行安全审计（如漏洞扫描、代码审查），及时修复潜在风险，确保系统长期稳定运行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/23/8000-%E5%AD%97%E4%BF%9D%E5%A7%86%E7%BA%A7%E5%AE%9E%E6%88%98%EF%BC%81%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%A8%E6%B5%81%E7%A8%8B%EF%BC%9A%E4%BB%8E%E9%9C%80%E6%B1%82%E6%8B%86%E8%A7%A3%E5%88%B0%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7%EF%BC%8C%E5%90%AB-JWT-Redis-%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E9%81%BF%E5%9D%91/" data-id="cuid2Dl4A_gRUbuNmfAe9e1ME" data-title="8000 字保姆级实战！登录功能后端开发全流程：从需求拆解到线上监控，含 JWT/Redis/ 第三方登录避坑" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/12/23/%E7%81%B5%E5%85%89%E7%A0%B4%E5%B1%80%EF%BC%9A%E9%98%BF%E9%87%8C%E7%B3%BB-AI-%E7%9A%84%E5%AE%9E%E7%94%A8%E4%B8%BB%E4%B9%89%E9%9D%A9%E5%91%BD%E4%B8%8E%E8%A1%8C%E4%B8%9A%E9%87%8D%E6%9E%84%E2%80%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          灵光破局：阿里系 AI 的实用主义革命与行业重构​
        
      </div>
    </a>
  
  
    <a href="/2025/12/23/%E4%B8%8B%E9%9D%A2%E4%B8%BA%E5%A4%A7%E5%AE%B6%E6%8F%90%E4%BE%9Bmysql%E7%9A%84%E5%AE%89%E8%A3%85%E5%8C%85%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">下面为大家提供mysql的安装包操作流程，包括初始化账号密码</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" rel="tag">代码拉取</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" rel="tag">文章，博客框架，技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" rel="tag">服务器，游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" rel="tag">权限配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" style="font-size: 10px;">代码拉取</a> <a href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">文章，博客框架，技术</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">服务器，游戏</a> <a href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">权限配置</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/">大模型微调</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E9%87%8C%E9%9D%A2%E7%9A%84%E2%80%98mcp%E2%80%99%E6%8A%80%E6%9C%AF/">计算机技术里面的‘mcp’技术</a>
          </li>
        
          <li>
            <a href="/2025/12/24/2025-8-19/">2025-8-19</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E9%82%A3%E4%BA%9B%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84-%E8%B6%85%E7%BA%A7%E9%BB%84%E9%87%91-bug-%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%AF%A5%E8%AE%B0%E5%8F%96%E7%9A%84%E8%A1%80%E6%B3%AA%E7%BB%8F%E9%AA%8C/">那些在公司工作中遇到的 &#39;超级黄金 bug&#39;：每个程序员都该记取的血泪经验</a>
          </li>
        
          <li>
            <a href="/2025/12/23/Java%E5%92%8Cgo%E8%AF%AD%E8%A8%80%E7%9A%842025%E5%B9%B4%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF%E5%92%8C%E5%B0%B1%E4%B8%9A%E5%BD%A2%E5%8A%BF/">Java和go语言的2025年发展前景和就业形势</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 little chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>