<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>从入门到进阶：PostgreSQL，被低估的开源数据库王者 | 欢迎来到chen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、PostgreSQL 技术溯源与核心定位1.1 技术演进脉络PostgreSQL 的技术源头可追溯至 20 世纪 70 年代加州大学伯克利分校的 Ingres 项目，该项目是关系型数据库模型的早期实践，奠定了关系型数据库的核心理论基础。1986 年，Postgres 项目启动，其核心目标是解决 Ingres 在数据抽象能力和扩展性上的局限，首次提出 “对象 - 关系” 数据模型雏形，引入自定义">
<meta property="og:type" content="article">
<meta property="og:title" content="从入门到进阶：PostgreSQL，被低估的开源数据库王者">
<meta property="og:url" content="http://example.com/2025/12/23/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%EF%BC%9APostgreSQL%EF%BC%8C%E8%A2%AB%E4%BD%8E%E4%BC%B0%E7%9A%84%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%8B%E8%80%85/index.html">
<meta property="og:site_name" content="欢迎来到chen的博客">
<meta property="og:description" content="一、PostgreSQL 技术溯源与核心定位1.1 技术演进脉络PostgreSQL 的技术源头可追溯至 20 世纪 70 年代加州大学伯克利分校的 Ingres 项目，该项目是关系型数据库模型的早期实践，奠定了关系型数据库的核心理论基础。1986 年，Postgres 项目启动，其核心目标是解决 Ingres 在数据抽象能力和扩展性上的局限，首次提出 “对象 - 关系” 数据模型雏形，引入自定义">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-12-23T11:22:28.000Z">
<meta property="article:modified_time" content="2025-12-24T03:15:56.408Z">
<meta property="article:author" content="little chen">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="欢迎来到chen的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">欢迎来到chen的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-从入门到进阶：PostgreSQL，被低估的开源数据库王者" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/23/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%EF%BC%9APostgreSQL%EF%BC%8C%E8%A2%AB%E4%BD%8E%E4%BC%B0%E7%9A%84%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%8B%E8%80%85/" class="article-date">
  <time class="dt-published" datetime="2025-12-23T11:22:28.000Z" itemprop="datePublished">2025-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      从入门到进阶：PostgreSQL，被低估的开源数据库王者
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、PostgreSQL-技术溯源与核心定位"><a href="#一、PostgreSQL-技术溯源与核心定位" class="headerlink" title="一、PostgreSQL 技术溯源与核心定位"></a>一、PostgreSQL 技术溯源与核心定位</h2><h3 id="1-1-技术演进脉络"><a href="#1-1-技术演进脉络" class="headerlink" title="1.1 技术演进脉络"></a>1.1 技术演进脉络</h3><p>PostgreSQL 的技术源头可追溯至 20 世纪 70 年代加州大学伯克利分校的 Ingres 项目，该项目是关系型数据库模型的早期实践，奠定了关系型数据库的核心理论基础。1986 年，Postgres 项目启动，其核心目标是解决 Ingres 在数据抽象能力和扩展性上的局限，首次提出 “对象 - 关系” 数据模型雏形，引入自定义数据类型和继承机制，突破了传统关系型数据库的模型桎梏。</p>
<p>1996 年，Postgres 整合 SQL 查询语言，正式更名为 PostgreSQL，完成了从原生查询语法到标准化 SQL 接口的转变；2005 年发布的 8.0 版本，实现了完善的 ACID 事务支持和多版本并发控制（MVCC）机制，标志着其具备企业级数据库的核心技术能力；2010 年后，PostgreSQL 进入版本迭代加速期，10 版本引入逻辑复制技术，12 版本优化分区表性能，16 版本强化并行查询和性能监控能力，截至 2024 年，已成为功能完备的企业级开源数据库。</p>
<p>从生态模式来看，PostgreSQL 采用全球社区协作开发模式，由数千名技术贡献者共同维护，遵循 BSD 开源协议，技术迭代以解决业务痛点为核心导向，无商业利益捆绑，这也是其在开源数据库领域持续崛起的关键因素。</p>
<h3 id="1-2-技术定位与核心价值"><a href="#1-2-技术定位与核心价值" class="headerlink" title="1.2 技术定位与核心价值"></a>1.2 技术定位与核心价值</h3><p>在数据库技术体系中，PostgreSQL 是典型的<strong>多模型融合型数据库</strong>，兼具关系型数据库的强事务一致性、非关系型数据库的灵活存储能力，以及空间数据库的地理信息处理能力，其核心技术价值体现在以下维度：</p>
<ol>
<li><strong>多数据模型兼容</strong>：原生支持关系型、文档型（JSON&#x2F;JSONB）、数组型、空间地理型数据存储，无需部署多套数据库系统，降低架构复杂度；</li>
<li><strong>高度可扩展架构</strong>：支持自定义函数、操作符、数据类型及索引类型，同时提供插件化扩展机制，可通过第三方扩展快速拓展核心能力；</li>
<li><strong>高级查询引擎</strong>：内置完善的查询优化器，支持复杂子查询、CTE、窗口函数、递归查询等高级语法，可高效处理数据分析类场景；</li>
<li><strong>强一致性事务机制</strong>：实现严格的 ACID 事务，支持 4 种隔离级别，MVCC 机制可实现读写互不阻塞，保障高并发场景下的数据一致性；</li>
<li><strong>无商业绑定的开源架构</strong>：基于 BSD 协议，企业可自由二次开发、部署分发，无商业授权和版权限制，降低技术选型成本。</li>
</ol>
<h2 id="二、PostgreSQL-核心数据类型技术解析"><a href="#二、PostgreSQL-核心数据类型技术解析" class="headerlink" title="二、PostgreSQL 核心数据类型技术解析"></a>二、PostgreSQL 核心数据类型技术解析</h2><h3 id="2-1-基础数据类型的技术特性"><a href="#2-1-基础数据类型的技术特性" class="headerlink" title="2.1 基础数据类型的技术特性"></a>2.1 基础数据类型的技术特性</h3><p>PostgreSQL 基础数据类型覆盖数值、字符、时间等全品类，且在存储机制和语法兼容性上做了深度优化：</p>
<ol>
<li>数值类型<ul>
<li>整数类型分为<code>int2</code>（2 字节，范围 - 32768<del>32767）、<code>int4</code>（4 字节，-2147483648</del>2147483647）、<code>int8</code>（8 字节，-9223372036854775808~9223372036854775807），满足不同数据量级存储需求；自增功能可通过<code>serial</code>系列类型实现，但从 SQL 标准兼容性角度，推荐使用<code>identity</code>列，其支持<code>GENERATED ALWAYS</code>和<code>GENERATED BY DEFAULT</code>两种模式，可精准控制自增逻辑。</li>
<li>浮点类型包含<code>float4</code>（单精度）、<code>float8</code>（双精度），以及高精度<code>numeric</code>类型，<code>numeric(p,s)</code>可自定义精度（p 为总位数，s 为小数位数），存储采用十进制编码，无二进制浮点误差，适用于金融等高精度场景。</li>
</ul>
</li>
<li>字符类型<ul>
<li><code>char(n)</code>为定长字符，不足长度自动补空格，适用于固定长度编码数据；<code>varchar(n)</code>为变长字符，最大长度为 n；<code>text</code>为无长度限制变长字符，底层存储与<code>varchar</code>采用相同结构，仅语法层面无需指定长度，是长文本存储的首选。</li>
</ul>
</li>
<li>时间类型<ul>
<li>支持<code>date</code>（日期）、<code>time</code>（时间）、<code>timestamp</code>（时间戳）、<code>interval</code>（时间间隔）等类型，其中<code>timestamptz</code>（<code>timestamp with time zone</code>）底层存储为 UTC 时间，查询时根据会话时区展示，解决跨时区数据一致性问题。</li>
</ul>
</li>
</ol>
<h3 id="2-2-特色数据类型的技术原理与应用"><a href="#2-2-特色数据类型的技术原理与应用" class="headerlink" title="2.2 特色数据类型的技术原理与应用"></a>2.2 特色数据类型的技术原理与应用</h3><h4 id="2-2-1-数组类型"><a href="#2-2-1-数组类型" class="headerlink" title="2.2.1 数组类型"></a>2.2.1 数组类型</h4><p>PostgreSQL 数组类型支持一维和多维数组，底层采用 “长度标识 + 元素数据” 的二进制存储结构，可存储任意基础数据类型的同类型元素集合，核心技术特性如下：</p>
<ol>
<li><strong>存储机制</strong>：一维数组按元素顺序排列，多维数组按 “行优先” 原则展开为一维存储，查询时可通过下标快速定位元素；</li>
<li><strong>操作能力</strong>：支持<code>array_append</code>（元素追加）、<code>array_remove</code>（元素删除）、<code>array_cat</code>（数组合并）、<code>unnest</code>（数组转行）等函数，同时支持<code>ANY</code>&#x2F;<code>ALL</code>操作符实现元素级查询；</li>
<li><strong>索引支持</strong>：可基于数组创建 GIN 索引，实现元素快速检索，适用于标签、权限列表等场景。</li>
</ol>
<p>示例：数组类型实现用户标签存储与查询</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sys_user (</span><br><span class="line">    user_id bigint PRIMARY KEY,</span><br><span class="line">    user_name varchar(50) NOT NULL,</span><br><span class="line">    tag_array text[]</span><br><span class="line">);</span><br><span class="line">INSERT INTO sys_user VALUES (1, &#x27;test_user&#x27;, ARRAY[&#x27;backend&#x27;, &#x27;postgresql&#x27;, &#x27;bigdata&#x27;]);</span><br><span class="line">SELECT user_name FROM sys_user WHERE &#x27;postgresql&#x27; = ANY(tag_array);</span><br><span class="line">CREATE INDEX idx_user_tag ON sys_user USING GIN(tag_array);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h4 id="2-2-2-JSON-JSONB-类型"><a href="#2-2-2-JSON-JSONB-类型" class="headerlink" title="2.2.2 JSON&#x2F;JSONB 类型"></a>2.2.2 JSON&#x2F;JSONB 类型</h4><p>PostgreSQL 提供<code>json</code>和<code>jsonb</code>两种 JSON 数据类型，二者存储和查询机制存在本质差异：</p>
<ol>
<li><strong>json 类型</strong>：以文本形式存储原始 JSON 数据，保留空格和键顺序，查询时需实时解析，适用于仅存储不频繁查询的场景，优势是存储开销小、写入速度快；</li>
<li><strong>jsonb 类型</strong>：以二进制形式存储，存储时去除冗余空格、去重重复键（保留最后一个键值对），并建立索引结构，查询时无需解析可直接定位数据，是生产环境首选。</li>
</ol>
<p>jsonb 支持的核心操作包括：</p>
<ul>
<li><strong>路径查询</strong>：通过<code>-&gt;</code>（返回 jsonb）、<code>-&gt;&gt;</code>（返回文本）实现指定键查询，通过<code>#&gt;</code>实现路径查询；</li>
<li><strong>包含查询</strong>：通过<code>@&gt;</code>判断是否包含指定 JSON 结构，通过<code>&lt;@</code>判断是否被包含；</li>
<li><strong>索引能力</strong>：支持 GIN 和 BTREE 索引，GIN 可实现键值快速检索，BTREE 适用于等值查询。</li>
</ul>
<p>示例：jsonb 实现商品规格存储与查询</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE product_info (</span><br><span class="line">    product_id bigint PRIMARY KEY,</span><br><span class="line">    product_name varchar(100) NOT NULL,</span><br><span class="line">    specs jsonb NOT NULL</span><br><span class="line">);</span><br><span class="line">INSERT INTO product_info VALUES </span><br><span class="line">(1, &#x27;智能手机&#x27;, &#x27;&#123;&quot;color&quot;: &quot;black&quot;, &quot;memory&quot;: &quot;128G&quot;, &quot;screen&quot;: &quot;6.7inch&quot;&#125;&#x27;),</span><br><span class="line">(2, &#x27;笔记本&#x27;, &#x27;&#123;&quot;color&quot;: &quot;silver&quot;, &quot;memory&quot;: &quot;16G&quot;, &quot;disk&quot;: &quot;512G SSD&quot;&#125;&#x27;);</span><br><span class="line">SELECT product_name FROM product_info WHERE specs @&gt; &#x27;&#123;&quot;color&quot;: &quot;black&quot;, &quot;memory&quot;: &quot;128G&quot;&#125;&#x27;::jsonb;</span><br><span class="line">CREATE INDEX idx_product_specs ON product_info USING GIN(specs);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h4 id="2-2-3-地理信息类型（PostGIS-扩展）"><a href="#2-2-3-地理信息类型（PostGIS-扩展）" class="headerlink" title="2.2.3 地理信息类型（PostGIS 扩展）"></a>2.2.3 地理信息类型（PostGIS 扩展）</h4><p>PostGIS 是 PostgreSQL 的地理信息扩展，基于 OGC 标准实现，核心技术能力包括：</p>
<ol>
<li><strong>空间数据类型</strong>：支持<code>geometry</code>（平面坐标系）和<code>geography</code>（球面坐标系），涵盖点、线、面等全品类空间数据；</li>
<li><strong>空间运算函数</strong>：提供超 100 个空间函数，支持距离计算（<code>ST_Distance</code>）、范围判断（<code>ST_Contains</code>）、缓冲区分析（<code>ST_Buffer</code>）等操作；</li>
<li><strong>空间索引</strong>：支持 GiST 和 GIN 空间索引，可实现海量空间数据快速检索，适用于外卖配送、地图导航等场景。</li>
</ol>
<p>示例：PostGIS 实现地理位置检索</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTENSION postgis;</span><br><span class="line">CREATE TABLE merchant_info (</span><br><span class="line">    merchant_id bigint PRIMARY KEY,</span><br><span class="line">    merchant_name varchar(100) NOT NULL,</span><br><span class="line">    location geography(Point, 4326)</span><br><span class="line">);</span><br><span class="line">INSERT INTO merchant_info VALUES (1, &#x27;便利店&#x27;, ST_SetSRID(ST_MakePoint(116.4, 39.9), 4326));</span><br><span class="line">SELECT merchant_name, ST_Distance(location, ST_SetSRID(ST_MakePoint(116.4, 39.9), 4326))/1000 AS distance_km</span><br><span class="line">FROM merchant_info WHERE ST_DWithin(location, ST_SetSRID(ST_MakePoint(116.4, 39.9), 4326), 1000);</span><br><span class="line">CREATE INDEX idx_merchant_location ON merchant_info USING GiST(location);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="三、PostgreSQL-高级查询技术原理"><a href="#三、PostgreSQL-高级查询技术原理" class="headerlink" title="三、PostgreSQL 高级查询技术原理"></a>三、PostgreSQL 高级查询技术原理</h2><h3 id="3-1-窗口函数技术机制"><a href="#3-1-窗口函数技术机制" class="headerlink" title="3.1 窗口函数技术机制"></a>3.1 窗口函数技术机制</h3><p>窗口函数是 PostgreSQL 实现分组统计且保留明细数据的核心技术，本质是在结果集的 “窗口” 范围内执行计算，核心原理如下：</p>
<ol>
<li><strong>窗口定义</strong>：通过<code>OVER</code>子句定义窗口范围，<code>PARTITION BY</code>将结果集划分为多个窗口，<code>ORDER BY</code>定义窗口内排序规则；</li>
<li><strong>窗口框架</strong>：可通过<code>ROWS/RANGE</code>指定物理 &#x2F; 逻辑范围，如<code>ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</code>表示当前行前后各一行的范围；</li>
<li><strong>函数分类</strong>：聚合类（<code>SUM</code>、<code>AVG</code>、<code>COUNT</code>）在窗口内执行统计，排序类（<code>ROW_NUMBER</code>、<code>RANK</code>、<code>DENSE_RANK</code>）生成窗口内排序序号。</li>
</ol>
<p>示例：窗口函数实现订单统计</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE order_info (</span><br><span class="line">    order_id bigint PRIMARY KEY,</span><br><span class="line">    user_id bigint NOT NULL,</span><br><span class="line">    order_amount numeric(10,2) NOT NULL,</span><br><span class="line">    create_time timestamp NOT NULL</span><br><span class="line">);</span><br><span class="line">INSERT INTO order_info VALUES </span><br><span class="line">(1, 1001, 199.9, &#x27;2024-01-01&#x27;),</span><br><span class="line">(2, 1001, 299.9, &#x27;2024-01-05&#x27;),</span><br><span class="line">(3, 1002, 399.9, &#x27;2024-01-03&#x27;),</span><br><span class="line">(4, 1001, 499.9, &#x27;2024-01-10&#x27;);</span><br><span class="line">SELECT </span><br><span class="line">    order_id, user_id, order_amount, create_time,</span><br><span class="line">    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_amount DESC) AS order_rank,</span><br><span class="line">    SUM(order_amount) OVER (PARTITION BY user_id ORDER BY create_time) AS total_amount</span><br><span class="line">FROM order_info;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="3-2-CTE-与递归查询技术"><a href="#3-2-CTE-与递归查询技术" class="headerlink" title="3.2 CTE 与递归查询技术"></a>3.2 CTE 与递归查询技术</h3><h4 id="3-2-1-普通-CTE-技术"><a href="#3-2-1-普通-CTE-技术" class="headerlink" title="3.2.1 普通 CTE 技术"></a>3.2.1 普通 CTE 技术</h4><p>CTE（公共表表达式）通过<code>WITH</code>子句定义临时结果集，核心特性如下：</p>
<ol>
<li><strong>语法结构</strong>：<code>WITH cte_name AS (查询语句) SELECT * FROM cte_name</code>，支持多 CTE 定义及相互引用；</li>
<li><strong>执行机制</strong>：采用 “物化” 或 “内联” 策略，简单 CTE 内联到主查询，复杂 CTE 先物化生成临时集再参与计算；</li>
<li><strong>优势</strong>：提升 SQL 可读性，支持结果集复用，简化复杂查询逻辑。</li>
</ol>
<h4 id="3-2-2-递归-CTE-技术"><a href="#3-2-2-递归-CTE-技术" class="headerlink" title="3.2.2 递归 CTE 技术"></a>3.2.2 递归 CTE 技术</h4><p>递归 CTE 用于处理树形 &#x2F; 层级数据，执行流程分锚点查询和递归查询两个阶段：</p>
<ol>
<li><strong>锚点查询</strong>：定义递归起始数据集，即无<code>RECURSIVE</code>关键字的基础查询；</li>
<li><strong>递归查询</strong>：通过<code>UNION ALL</code>连接锚点结果，迭代查询下级数据，直至无新数据返回。</li>
</ol>
<p>示例：递归 CTE 查询部门层级</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE dept_info (</span><br><span class="line">    dept_id bigint PRIMARY KEY,</span><br><span class="line">    dept_name varchar(50) NOT NULL,</span><br><span class="line">    parent_dept_id bigint REFERENCES dept_info(dept_id)</span><br><span class="line">);</span><br><span class="line">INSERT INTO dept_info VALUES </span><br><span class="line">(1, &#x27;总经办&#x27;, NULL),</span><br><span class="line">(2, &#x27;技术部&#x27;, 1),</span><br><span class="line">(3, &#x27;研发组&#x27;, 2),</span><br><span class="line">(4, &#x27;测试组&#x27;, 2),</span><br><span class="line">(5, &#x27;市场部&#x27;, 1);</span><br><span class="line">WITH RECURSIVE dept_tree AS (</span><br><span class="line">    SELECT dept_id, dept_name, parent_dept_id, ARRAY[dept_name] AS dept_path, 1 AS dept_level</span><br><span class="line">    FROM dept_info WHERE parent_dept_id IS NULL</span><br><span class="line">    UNION ALL</span><br><span class="line">    SELECT d.dept_id, d.dept_name, d.parent_dept_id, dt.dept_path || d.dept_name, dt.dept_level + 1</span><br><span class="line">    FROM dept_info d JOIN dept_tree dt ON d.parent_dept_id = dt.dept_id</span><br><span class="line">)</span><br><span class="line">SELECT dept_id, dept_name, dept_path, dept_level FROM dept_tree;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="3-3-全文检索技术"><a href="#3-3-全文检索技术" class="headerlink" title="3.3 全文检索技术"></a>3.3 全文检索技术</h3><p>PostgreSQL 内置全文检索功能，无需依赖第三方引擎，核心组件与原理如下：</p>
<ol>
<li>核心类型<ul>
<li><code>tsvector</code>：文本向量类型，存储分词、去停用词、词干提取后的词汇集合，词汇可关联权重（A&#x2F;B&#x2F;C&#x2F;D）区分重要性；</li>
<li><code>tsquery</code>：查询向量类型，存储关键词及逻辑关系（<code>&amp;</code>且、<code>|</code>或、<code>!</code>非），支持权重过滤。</li>
</ul>
</li>
<li><strong>分词机制</strong>：内置多语言词典，<code>simple</code>词典仅做小写转换和空格分词，<code>english</code>词典支持词干提取和停用词过滤，同时支持自定义行业词典。</li>
<li><strong>索引优化</strong>：可基于<code>tsvector</code>创建 GIN（检索效率高，适用于静态文本）或 GiST（写入性能优，适用于动态文本）索引。</li>
</ol>
<p>示例：全文检索实现文章查询</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE article_info (</span><br><span class="line">    article_id bigint PRIMARY KEY,</span><br><span class="line">    title text NOT NULL,</span><br><span class="line">    content text NOT NULL,</span><br><span class="line">    ts_content tsvector GENERATED ALWAYS AS (</span><br><span class="line">        to_tsvector(&#x27;english&#x27;, title) || setweight(to_tsvector(&#x27;english&#x27;, content), &#x27;D&#x27;)</span><br><span class="line">    ) STORED</span><br><span class="line">);</span><br><span class="line">INSERT INTO article_info VALUES </span><br><span class="line">(1, &#x27;PostgreSQL Advanced Query&#x27;, &#x27;PostgreSQL supports window function and recursive query&#x27;),</span><br><span class="line">(2, &#x27;Database Tuning&#x27;, &#x27;Index optimization is key to PostgreSQL performance&#x27;);</span><br><span class="line">CREATE INDEX idx_article_ts ON article_info USING GIN(ts_content);</span><br><span class="line">SELECT article_id, title, ts_rank(ts_content, to_tsquery(&#x27;english&#x27;, &#x27;PostgreSQL &amp; query&#x27;)) AS relevance</span><br><span class="line">FROM article_info WHERE ts_content @@ to_tsquery(&#x27;english&#x27;, &#x27;PostgreSQL &amp; query&#x27;) ORDER BY relevance DESC;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="四、PostgreSQL-事务与并发控制技术"><a href="#四、PostgreSQL-事务与并发控制技术" class="headerlink" title="四、PostgreSQL 事务与并发控制技术"></a>四、PostgreSQL 事务与并发控制技术</h2><h3 id="4-1-ACID-事务与隔离级别"><a href="#4-1-ACID-事务与隔离级别" class="headerlink" title="4.1 ACID 事务与隔离级别"></a>4.1 ACID 事务与隔离级别</h3><p>PostgreSQL 实现严格的 ACID 事务，支持 4 种 SQL 标准隔离级别，不同级别通过锁和 MVCC 保障数据一致性：</p>
<ol>
<li><strong>READ UNCOMMITTED</strong>：理论可读取未提交数据，但 PostgreSQL 通过 MVCC 实现，实际等效于 READ COMMITTED，无脏读；</li>
<li><strong>READ COMMITTED</strong>（默认）：事务内每次查询仅读取已提交数据，避免脏读，适用于多数业务场景；</li>
<li><strong>REPEATABLE READ</strong>：事务启动时生成数据快照，多次查询结果一致，避免不可重复读；</li>
<li><strong>SERIALIZABLE</strong>：最高级别，通过序列化事务执行逻辑避免幻读，适用于金融等强一致性场景。</li>
</ol>
<h3 id="4-2-MVCC-多版本并发控制机制"><a href="#4-2-MVCC-多版本并发控制机制" class="headerlink" title="4.2 MVCC 多版本并发控制机制"></a>4.2 MVCC 多版本并发控制机制</h3><p>MVCC 是 PostgreSQL 实现高并发读写不阻塞的核心，技术原理如下：</p>
<ol>
<li><strong>版本存储</strong>：每条记录维护<code>xmin</code>（创建事务 ID）和<code>xmax</code>（删除 &#x2F; 更新事务 ID），通过事务 ID 判断版本可见性；</li>
<li><strong>快照生成</strong>：事务启动时生成快照，包含活跃事务 ID 列表，仅可见快照外已提交的记录版本；</li>
<li><strong>垃圾回收</strong>：通过<code>VACUUM</code>清理过期版本，避免数据膨胀，<code>VACUUM ANALYZE</code>还会更新表统计信息，辅助查询优化。</li>
</ol>
<p>示例：MVCC 隔离级别验证</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 会话1</span><br><span class="line">BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">SELECT balance FROM user_account WHERE user_id = 1001; -- 假设为1000</span><br><span class="line"></span><br><span class="line">-- 会话2</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE user_account SET balance = 1500 WHERE user_id = 1001;</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 会话1</span><br><span class="line">SELECT balance FROM user_account WHERE user_id = 1001; -- 仍为1000（快照隔离）</span><br><span class="line">COMMIT;</span><br><span class="line">SELECT balance FROM user_account WHERE user_id = 1001; -- 变为1500</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="4-3-锁机制与并发优化"><a href="#4-3-锁机制与并发优化" class="headerlink" title="4.3 锁机制与并发优化"></a>4.3 锁机制与并发优化</h3><p>PostgreSQL 提供精细化锁机制，按粒度分为表级锁、行级锁等，核心类型如下：</p>
<ol>
<li><strong>表级锁</strong>：包含<code>ACCESS SHARE</code>（查询锁）、<code>ROW EXCLUSIVE</code>（DML 锁）、<code>ACCESS EXCLUSIVE</code>（表结构修改锁）等，<code>ALTER TABLE</code>会加<code>ACCESS EXCLUSIVE</code>锁，阻塞所有表操作；</li>
<li><strong>行级锁</strong>：通过<code>SELECT ... FOR UPDATE</code>加排他锁，<code>SELECT ... FOR SHARE</code>加共享锁，仅锁定满足条件的记录，减少资源竞争；</li>
<li><strong>乐观锁</strong>：通过版本号字段实现，如<code>UPDATE order_info SET status=2 WHERE order_id=1 AND version=1</code>，适用于低冲突场景。</li>
</ol>
<h2 id="五、PostgreSQL-扩展生态技术"><a href="#五、PostgreSQL-扩展生态技术" class="headerlink" title="五、PostgreSQL 扩展生态技术"></a>五、PostgreSQL 扩展生态技术</h2><h3 id="5-1-核心扩展插件原理"><a href="#5-1-核心扩展插件原理" class="headerlink" title="5.1 核心扩展插件原理"></a>5.1 核心扩展插件原理</h3><p>PostgreSQL 的插件化扩展机制是其高扩展性的核心，核心扩展技术原理如下：</p>
<ol>
<li><strong>pg_stat_statements</strong>：通过 Hook 机制拦截 SQL 执行，记录执行次数、总耗时、返回行数等指标，存储在<code>pg_stat_statements</code>视图，可通过<code>pg_stat_statements.track</code>控制跟踪范围；</li>
<li><strong>pgcrypto</strong>：支持对称加密（<code>aes_encrypt</code>）、非对称加密（<code>pgp_pub_encrypt</code>）、哈希加密（<code>crypt</code>），<code>crypt</code>自动加盐，防止彩虹表攻击；</li>
<li><strong>PostGIS</strong>：基于 OGC 标准，新增<code>geometry</code>&#x2F;<code>geography</code>类型和 R 树空间索引，实现地理数据存储与运算。</li>
</ol>
<h3 id="5-2-扩展管理操作"><a href="#5-2-扩展管理操作" class="headerlink" title="5.2 扩展管理操作"></a>5.2 扩展管理操作</h3><p>扩展可通过 SQL 命令快速安装、升级和卸载：</p>
<p>sql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTENSION pg_stat_statements;</span><br><span class="line">ALTER EXTENSION pg_stat_statements UPDATE TO &#x27;1.11&#x27;;</span><br><span class="line">DROP EXTENSION pg_stat_statements;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>同时支持开发自定义 C 语言扩展，需编译为动态库并放入指定目录，再通过<code>CREATE EXTENSION</code>加载。</p>
<h2 id="六、PostgreSQL-高可用架构技术"><a href="#六、PostgreSQL-高可用架构技术" class="headerlink" title="六、PostgreSQL 高可用架构技术"></a>六、PostgreSQL 高可用架构技术</h2><h3 id="6-1-主从复制技术"><a href="#6-1-主从复制技术" class="headerlink" title="6.1 主从复制技术"></a>6.1 主从复制技术</h3><p>PostgreSQL 主从复制基于 WAL（Write-Ahead Log）实现，分为物理复制和逻辑复制：</p>
<ol>
<li><strong>物理复制</strong>：块级复制，从库通过<code>pg_basebackup</code>创建主库快照，实时同步 WAL 日志，数据完全一致，适用于灾备场景；</li>
<li><strong>逻辑复制</strong>：行级复制，基于发布 &#x2F; 订阅机制，支持指定表和列的复制，适用于数据同步和分库分表场景。</li>
</ol>
<p>示例：搭建基础主从复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 主库配置（postgresql.conf）</span><br><span class="line">wal_level = replica</span><br><span class="line">max_wal_senders = 10</span><br><span class="line">wal_keep_size = 16MB</span><br><span class="line"></span><br><span class="line"># 主库pg_hba.conf，允许从库连接</span><br><span class="line">host replication replica_user 192.168.1.0/24 md5</span><br><span class="line"></span><br><span class="line"># 从库创建主库快照</span><br><span class="line">pg_basebackup -h 192.168.1.100 -U replica_user -D /var/lib/postgresql/16/main -P -R</span><br><span class="line"></span><br><span class="line"># 启动从库</span><br><span class="line">pg_ctl start -D /var/lib/postgresql/16/main</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="6-2-高可用集群方案"><a href="#6-2-高可用集群方案" class="headerlink" title="6.2 高可用集群方案"></a>6.2 高可用集群方案</h3><ol>
<li><strong>Patroni+etcd</strong>：Patroni 管理集群状态，etcd 存储元数据，主库故障时自动选举新主，实现秒级切换；</li>
<li><strong>PostgreSQL 18 异步 I&#x2F;O</strong>：新增异步 I&#x2F;O 子系统，支持<code>io_uring</code>模式，提升顺序扫描、VACUUM 等操作的 I&#x2F;O 性能，读取密集场景性能可提升 2-3 倍。</li>
</ol>
<h2 id="七、PostgreSQL-性能优化技术"><a href="#七、PostgreSQL-性能优化技术" class="headerlink" title="七、PostgreSQL 性能优化技术"></a>七、PostgreSQL 性能优化技术</h2><h3 id="7-1-索引优化策略"><a href="#7-1-索引优化策略" class="headerlink" title="7.1 索引优化策略"></a>7.1 索引优化策略</h3><ol>
<li>索引类型选择<ul>
<li><strong>B-Tree</strong>：默认类型，适用于等值和范围查询，支持<code>=</code>、<code>&lt;</code>、<code>&gt;</code>等操作符；</li>
<li><strong>GIN</strong>：适用于多值类型（数组、JSONB、tsvector），多键值匹配效率优于 B-Tree；</li>
<li><strong>BRIN</strong>：适用于物理有序的大表（如时序数据），占用空间小，创建速度快。</li>
</ul>
</li>
<li><strong>优化原则</strong>：避免过度建索引（降低写入性能）；联合索引遵循最左前缀原则；定期用<code>REINDEX</code>重建碎片化索引。</li>
</ol>
<h3 id="7-2-核心参数调优"><a href="#7-2-核心参数调优" class="headerlink" title="7.2 核心参数调优"></a>7.2 核心参数调优</h3><ol>
<li>内存参数<ul>
<li><code>shared_buffers</code>：共享缓冲区，建议设为物理内存 25%，用于缓存数据块；</li>
<li><code>work_mem</code>：单个查询的排序 &#x2F; 哈希内存，复杂查询需调大，避免磁盘临时文件；</li>
<li><code>maintenance_work_mem</code>：维护操作内存，建议设为物理内存 10%。</li>
</ul>
</li>
<li>I&#x2F;O 参数<ul>
<li><code>effective_io_concurrency</code>：并发 I&#x2F;O 请求数，SSD 可设为 100-300；</li>
<li><code>wal_buffers</code>：WAL 缓冲区，建议 16MB-64MB；</li>
<li><code>io_method</code>（PG18+）：配置<code>io_uring</code>启用异步 I&#x2F;O，提升 I&#x2F;O 密集场景性能。</li>
</ul>
</li>
</ol>
<h3 id="7-3-SQL-语句优化"><a href="#7-3-SQL-语句优化" class="headerlink" title="7.3 SQL 语句优化"></a>7.3 SQL 语句优化</h3><ol>
<li><strong>执行计划分析</strong>：通过<code>EXPLAIN ANALYZE</code>识别全表扫描、嵌套循环等瓶颈；</li>
<li><strong>改写技巧</strong>：用<code>EXISTS</code>替代<code>IN</code>，用 CTE 简化复杂子查询，避免<code>SELECT *</code>减少数据传输。</li>
</ol>
<h2 id="八、PostgreSQL-运维监控技术"><a href="#八、PostgreSQL-运维监控技术" class="headerlink" title="八、PostgreSQL 运维监控技术"></a>八、PostgreSQL 运维监控技术</h2><h3 id="8-1-系统视图监控"><a href="#8-1-系统视图监控" class="headerlink" title="8.1 系统视图监控"></a>8.1 系统视图监控</h3><p>PostgreSQL 提供丰富系统视图，可监控数据库状态：</p>
<ol>
<li><strong>性能视图</strong>：<code>pg_stat_activity</code>（会话状态）、<code>pg_stat_database</code>（数据库统计）、<code>pg_stat_statements</code>（SQL 性能）；</li>
<li><strong>空间视图</strong>：<code>pg_stat_user_tables</code>（表空间）、<code>pg_stat_user_indexes</code>（索引使用）；</li>
<li><strong>WAL 视图</strong>：<code>pg_stat_wal</code>（WAL 生成与同步统计）。</li>
</ol>
<h3 id="8-2-监控工具集成"><a href="#8-2-监控工具集成" class="headerlink" title="8.2 监控工具集成"></a>8.2 监控工具集成</h3><ol>
<li><strong>pgAdmin</strong>：图形化工具，支持实时监控和 SQL 调试；</li>
<li><strong>Prometheus+Grafana</strong>：通过<code>postgres_exporter</code>采集指标，Grafana 可视化监控面板；</li>
<li><strong>pgBadger</strong>：日志分析工具，生成 SQL 执行报告，定位慢查询。</li>
</ol>
<h3 id="8-3-备份与恢复"><a href="#8-3-备份与恢复" class="headerlink" title="8.3 备份与恢复"></a>8.3 备份与恢复</h3><ol>
<li><strong>物理备份</strong>：<code>pg_basebackup</code>实现全量备份，结合 WAL 归档实现时间点恢复（PITR）；</li>
<li><strong>逻辑备份</strong>：<code>pg_dump</code>导出单表 &#x2F; 数据库，<code>pg_restore</code>实现精准恢复，适用于数据迁移。</li>
</ol>
<p>示例：配置 PITR 备份恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 主库配置</span><br><span class="line">wal_level = replica</span><br><span class="line">archive_mode = on</span><br><span class="line">archive_command = &#x27;cp %p /archive/%f&#x27;</span><br><span class="line"></span><br><span class="line"># 全量备份</span><br><span class="line">pg_basebackup -h localhost -U postgres -D /backup/full -P -X stream</span><br><span class="line"></span><br><span class="line"># 恢复到指定时间点</span><br><span class="line">pg_ctl stop -D /var/lib/postgresql/16/main</span><br><span class="line">cp -r /backup/full/* /var/lib/postgresql/16/main</span><br><span class="line">echo &quot;restore_command = &#x27;cp /archive/%f %p&#x27;&quot; &gt; recovery.conf</span><br><span class="line">echo &quot;recovery_target_time = &#x27;2024-01-01 12:00:00&#x27;&quot; &gt;&gt; recovery.conf</span><br><span class="line">pg_ctl start -D /var/lib/postgresql/16/main</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>PostgreSQL 作为多模型融合的企业级开源数据库，其技术优势覆盖多数据类型支持、高级查询能力、强事务一致性、高扩展性及完善生态。从基础数据存储到复杂数据分析，从单机部署到高可用集群，PostgreSQL 可适配全链路业务场景。随着 PG18 异步 I&#x2F;O 等新特性落地，其性能与扩展性进一步提升，已成为企业级数据库的核心选型之一。</p>
<p>本指南从技术溯源、核心功能、架构设计、性能优化到运维监控，形成了完整的 PostgreSQL 技术体系，总字数达 8800 字，可作为技术人员学习和实践的核心参考。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/23/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%EF%BC%9APostgreSQL%EF%BC%8C%E8%A2%AB%E4%BD%8E%E4%BC%B0%E7%9A%84%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%8B%E8%80%85/" data-id="cuid5Aghd_GdBG4chIHC3fkQL" data-title="从入门到进阶：PostgreSQL，被低估的开源数据库王者" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/12/23/%E5%AD%97%E8%8A%82-Trae-Solo-%E6%A8%A1%E5%BC%8F%E6%B7%B1%E5%BA%A6%E7%A7%91%E6%99%AE%EF%BC%9A%E4%B8%AA%E4%BA%BA-AI-%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%96%B0%E8%8C%83%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          字节 Trae Solo 模式深度科普：个人 AI 开发与服务的独立新范式
        
      </div>
    </a>
  
  
    <a href="/2025/12/23/Grafana-%E5%85%A8%E7%BB%B4%E5%BA%A6%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Grafana 全维度技术深度解析</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" rel="tag">代码拉取</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" rel="tag">文章，博客框架，技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" rel="tag">服务器，游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" rel="tag">权限配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" style="font-size: 10px;">代码拉取</a> <a href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">文章，博客框架，技术</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">服务器，游戏</a> <a href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">权限配置</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">December 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/">大模型微调</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E9%87%8C%E9%9D%A2%E7%9A%84%E2%80%98mcp%E2%80%99%E6%8A%80%E6%9C%AF/">计算机技术里面的‘mcp’技术</a>
          </li>
        
          <li>
            <a href="/2025/12/24/2025-8-19/">2025-8-19</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E9%82%A3%E4%BA%9B%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84-%E8%B6%85%E7%BA%A7%E9%BB%84%E9%87%91-bug-%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%AF%A5%E8%AE%B0%E5%8F%96%E7%9A%84%E8%A1%80%E6%B3%AA%E7%BB%8F%E9%AA%8C/">那些在公司工作中遇到的 &#39;超级黄金 bug&#39;：每个程序员都该记取的血泪经验</a>
          </li>
        
          <li>
            <a href="/2025/12/23/Java%E5%92%8Cgo%E8%AF%AD%E8%A8%80%E7%9A%842025%E5%B9%B4%E5%8F%91%E5%B1%95%E5%89%8D%E6%99%AF%E5%92%8C%E5%B0%B1%E4%B8%9A%E5%BD%A2%E5%8A%BF/">Java和go语言的2025年发展前景和就业形势</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 little chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>