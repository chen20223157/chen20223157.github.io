<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JNI 完全指南：从 Java 到 Native 的深度探索与实战 | 欢迎来到chen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="引言：JNI 的核心价值与应用场景Java Native Interface（JNI）作为 Java 平台的核心特性之一，自 JDK 1.1 起便成为连接 Java 虚拟机与原生代码（C&#x2F;C++、汇编等）的桥梁。在 Java 以 “一次编写，到处运行” 的跨平台特性风靡业界的同时，JNI 为其弥补了三大关键短板：一是访问底层系统资源，如操作系统 API、硬件驱动等 Java 无法直接触及">
<meta property="og:type" content="article">
<meta property="og:title" content="JNI 完全指南：从 Java 到 Native 的深度探索与实战">
<meta property="og:url" content="http://example.com/2025/12/23/JNI-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E-Java-%E5%88%B0-Native-%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="欢迎来到chen的博客">
<meta property="og:description" content="引言：JNI 的核心价值与应用场景Java Native Interface（JNI）作为 Java 平台的核心特性之一，自 JDK 1.1 起便成为连接 Java 虚拟机与原生代码（C&#x2F;C++、汇编等）的桥梁。在 Java 以 “一次编写，到处运行” 的跨平台特性风靡业界的同时，JNI 为其弥补了三大关键短板：一是访问底层系统资源，如操作系统 API、硬件驱动等 Java 无法直接触及">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-23T10:01:55.000Z">
<meta property="article:modified_time" content="2025-12-24T03:24:52.338Z">
<meta property="article:author" content="little chen">
<meta property="article:tag" content="测试开发,后端开发，测试">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="欢迎来到chen的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">欢迎来到chen的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个专注于技术分享的博客，详情可访问我的csdn——&gt;id:weixin_73527660</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JNI-完全指南：从-Java-到-Native-的深度探索与实战" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/12/23/JNI-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E-Java-%E5%88%B0-Native-%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E6%88%98/" class="article-date">
  <time class="dt-published" datetime="2025-12-23T10:01:55.000Z" itemprop="datePublished">2025-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JNI 完全指南：从 Java 到 Native 的深度探索与实战
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="引言：JNI-的核心价值与应用场景"><a href="#引言：JNI-的核心价值与应用场景" class="headerlink" title="引言：JNI 的核心价值与应用场景"></a>引言：JNI 的核心价值与应用场景</h1><p>Java Native Interface（JNI）作为 Java 平台的核心特性之一，自 JDK 1.1 起便成为连接 Java 虚拟机与原生代码（C&#x2F;C++、汇编等）的桥梁。在 Java 以 “一次编写，到处运行” 的跨平台特性风靡业界的同时，JNI 为其弥补了三大关键短板：一是访问底层系统资源，如操作系统 API、硬件驱动等 Java 无法直接触及的层面；二是复用现有原生代码库，避免重复开发成熟的 C&#x2F;C++ 组件；三是优化性能瓶颈，将计算密集型任务（如图像处理、加密解密）交由原生代码执行，突破 Java 虚拟机的性能限制。</p>
<p>如今，JNI 的应用已渗透到各类软件系统中：Android 开发中通过 JNI 调用 C&#x2F;C++ 实现音视频编解码、游戏引擎；大数据领域利用 JNI 整合 Hadoop 生态中的 C 语言计算模块；金融系统借助 JNI 调用底层加密库保障数据安全。但 JNI 的强大背后也暗藏风险 —— 内存泄漏、线程安全问题、跨平台兼容性故障等，往往让开发者望而却步。本文将从基础原理出发，逐步深入 JNI 的开发全流程，结合实战案例与避坑指南，帮助开发者真正掌握这门 “Java 与原生世界的通信艺术”。</p>
<h1 id="一、JNI-核心概念与架构原理"><a href="#一、JNI-核心概念与架构原理" class="headerlink" title="一、JNI 核心概念与架构原理"></a>一、JNI 核心概念与架构原理</h1><h2 id="1-1-JNI-的定义与设计目标"><a href="#1-1-JNI-的定义与设计目标" class="headerlink" title="1.1 JNI 的定义与设计目标"></a>1.1 JNI 的定义与设计目标</h2><p>JNI 是 Java 虚拟机规范定义的一套编程接口，其核心目标是实现 “双向交互”：Java 代码可以调用原生代码，原生代码也能反向访问 Java 虚拟机中的对象、方法和字段。与其他跨语言方案（如 JNA、SWIG）相比，JNI 的优势在于直接与虚拟机底层交互，性能损耗最小，但代价是需要手动管理跨语言调用的细节。</p>
<p>JNI 的设计遵循三大原则：</p>
<ul>
<li><p>二进制兼容性：原生库编译后生成的二进制文件（.so&#x2F;.dll&#x2F;.dylib）可在不同 Java 虚拟机实现中运行，无需重新编译；</p>
</li>
<li><p>平台无关性：JNI 接口本身不依赖特定操作系统，原生代码的跨平台性需由开发者自行保障；</p>
</li>
<li><p>最小侵入性：JNI 不改变 Java 语言的语义，仅通过特定语法和 API 实现与原生代码的交互。</p>
</li>
</ul>
<h2 id="1-2-JNI-的架构层次"><a href="#1-2-JNI-的架构层次" class="headerlink" title="1.2 JNI 的架构层次"></a>1.2 JNI 的架构层次</h2><p>JNI 的交互过程涉及三个核心层次，从上层到下层依次为：</p>
<p>Java 应用层：包含声明 native 方法的 Java 类，作为调用原生代码的入口；</p>
<p>JNI 桥接层：由 JNI 头文件（.h）、原生实现文件（.c&#x2F;.cpp）组成，负责解析 Java 虚拟机传递的参数、调用原生逻辑、返回结果给 Java 层；</p>
<p>原生代码层：既可以是自定义的 C&#x2F;C++ 代码，也可以是第三方原生库（如 OpenCV、FFmpeg），实现核心业务逻辑。</p>
<p>其底层通信原理是：Java 虚拟机通过 JNI 接口加载原生库（.so&#x2F;.dll），当 Java 代码调用 native 方法时，虚拟机通过方法名映射找到对应的原生函数，将 Java 对象、参数转换为原生代码可识别的格式（如 jobject、jint），执行原生函数后，再将返回值转换为 Java 类型并返回给 Java 层。</p>
<h2 id="1-3-JNI-关键数据类型"><a href="#1-3-JNI-关键数据类型" class="headerlink" title="1.3 JNI 关键数据类型"></a>1.3 JNI 关键数据类型</h2><p>JNI 定义了一套与 Java 类型对应的原生数据类型，分为基本类型和引用类型两类，确保跨语言数据传递的一致性。</p>
<h3 id="1-3-1-基本数据类型"><a href="#1-3-1-基本数据类型" class="headerlink" title="1.3.1 基本数据类型"></a>1.3.1 基本数据类型</h3><p>JNI 的基本类型直接映射 Java 的基本类型，无额外开销，具体对应关系如下：</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>JNI 类型</th>
<th>原生 C&#x2F;C++ 类型</th>
<th>占用字节数</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>jboolean</td>
<td>unsigned char</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
<td>signed char</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
<td>unsigned short</td>
<td>2</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
<td>long long</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>double</td>
<td>8</td>
</tr>
</tbody></table>
<p>其中，JNI 还定义了jsize类型（等价于jint），用于表示数组长度等计数场景。</p>
<h3 id="1-3-2-引用类型"><a href="#1-3-2-引用类型" class="headerlink" title="1.3.2 引用类型"></a>1.3.2 引用类型</h3><p>JNI 的引用类型对应 Java 的引用类型（对象、数组等），本质是指向 Java 虚拟机内部对象的指针，不能直接在原生代码中操作，需通过 JNI 提供的 API 进行访问。核心引用类型包括：</p>
<table>
<thead>
<tr>
<th>JNI 引用类型</th>
<th>对应 Java 类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>jobject</td>
<td>Object</td>
<td>所有 Java 对象的基类</td>
</tr>
<tr>
<td>jclass</td>
<td>Class</td>
<td>Java 类对象</td>
</tr>
<tr>
<td>jstring</td>
<td>String</td>
<td>字符串对象</td>
</tr>
<tr>
<td>jarray</td>
<td>所有数组的基类</td>
<td>数组通用类型</td>
</tr>
<tr>
<td>jobjectArray</td>
<td>Object[]</td>
<td>对象数组</td>
</tr>
<tr>
<td>jbooleanArray</td>
<td>boolean[]</td>
<td>布尔数组</td>
</tr>
<tr>
<td>jbyteArray</td>
<td>byte[]</td>
<td>字节数组</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>其他基本类型数组</td>
</tr>
<tr>
<td>jthrowable</td>
<td>Throwable</td>
<td>异常对象</td>
</tr>
</tbody></table>
<p>需要注意的是，引用类型在原生代码中需严格遵循 JNI 的内存管理规则，否则会导致内存泄漏或虚拟机崩溃。</p>
<h1 id="二、JNI-开发全流程实战（以-C-语言为例）"><a href="#二、JNI-开发全流程实战（以-C-语言为例）" class="headerlink" title="二、JNI 开发全流程实战（以 C 语言为例）"></a>二、JNI 开发全流程实战（以 C 语言为例）</h1><h2 id="2-1-开发环境准备"><a href="#2-1-开发环境准备" class="headerlink" title="2.1 开发环境准备"></a>2.1 开发环境准备</h2><h3 id="2-1-1-基础环境"><a href="#2-1-1-基础环境" class="headerlink" title="2.1.1 基础环境"></a>2.1.1 基础环境</h3><ul>
<li><p>JDK：推荐 JDK 8 及以上（需配置 JAVA_HOME 环境变量）；</p>
</li>
<li><p>原生编译器：Windows 平台使用 MinGW 或 MSVC，Linux 平台使用 GCC，MacOS 平台使用 Clang；</p>
</li>
<li><p>开发工具：Java 代码可使用 IDEA&#x2F;Eclipse，原生代码可使用 VS Code、CLion 等。</p>
</li>
</ul>
<h3 id="2-1-2-环境验证"><a href="#2-1-2-环境验证" class="headerlink" title="2.1.2 环境验证"></a>2.1.2 环境验证</h3><p>在命令行中执行以下命令，验证环境是否配置成功：</p>
<h2 id="2-2-第一步：编写声明-native-方法的-Java-类"><a href="#2-2-第一步：编写声明-native-方法的-Java-类" class="headerlink" title="2.2 第一步：编写声明 native 方法的 Java 类"></a>2.2 第一步：编写声明 native 方法的 Java 类</h2><p>native 方法是 Java 调用原生代码的入口，需使用native关键字声明，且不能包含方法体。同时，需通过System.loadLibrary()或System.load()方法加载原生库。</p>
<p>示例：JavaNativeDemo.java</p>
<p>关键说明：</p>
<ul>
<li><p>System.loadLibrary()：加载系统默认库路径下的原生库，库名无需带前缀（如lib）和后缀（如.so）；</p>
</li>
<li><p>System.load()：加载指定路径的原生库，需传入完整路径（如D:&#x2F;libs&#x2F;JavaNativeDemo.dll）；</p>
</li>
<li><p>native 方法的访问修饰符可以是public、protected或默认，但通常声明为public以便外部调用。</p>
</li>
</ul>
<h2 id="2-3-第二步：生成-JNI-头文件（-h）"><a href="#2-3-第二步：生成-JNI-头文件（-h）" class="headerlink" title="2.3 第二步：生成 JNI 头文件（.h）"></a>2.3 第二步：生成 JNI 头文件（.h）</h2><p>JNI 头文件由javac命令自动生成，包含原生函数的声明，其文件名格式为包名+类名.h（包名中的.替换为_）。生成头文件的核心是让javac识别 native 方法，并按照 JNI 规范生成对应的原生函数签名。</p>
<p>生成步骤：</p>
<p>进入 Java 类的源文件所在目录（假设 Java 文件在src&#x2F;main&#x2F;java目录下，包名为com.example.jni）；</p>
<p>执行以下命令生成 class 文件和头文件：</p>
<p># -d：指定class文件输出目录（需与包结构一致）</p>
<p># -h：指定头文件输出目录（通常为jni目录）</p>
<p>javac -d target&#x2F;classes -h jni src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;jni&#x2F;JavaNativeDemo.java</p>
<p>生成的头文件：com_example_jni_JavaNativeDemo.h</p>
<p>头文件关键解析：</p>
<p>预处理指令：#ifndef _Included_xxx避免头文件重复包含；</p>
<p>extern “C”：确保 C++ 编译器按 C 语言规则编译函数（避免函数名被篡改）；</p>
<p>函数声明格式：JNIEXPORT 返回类型 JNICALL 函数名(JNIEnv *, jobject, 其他参数)；</p>
<ul>
<li><p>JNIEXPORT：标记函数为 JNI 导出函数，允许 Java 虚拟机调用；</p>
</li>
<li><p>JNICALL：指定函数调用约定（如栈帧布局、参数传递顺序），确保跨平台兼容性；</p>
</li>
<li><p>JNIEnv *：JNI 环境指针，包含所有 JNI 核心 API（如创建对象、访问字段、调用方法）；</p>
</li>
<li><p>jobject：对应 Java 中的this对象（非静态 native 方法），若为静态 native 方法则为jclass（对应 Java 类对象）；</p>
</li>
<li><p>后续参数：与 Java native 方法的参数一一对应，类型为 JNI 数据类型。</p>
</li>
</ul>
<p>Signature：方法签名，用于 Java 虚拟机区分重载方法，格式规则如下：</p>
<ul>
<li><p>基本类型：用单个字符表示（如Z&#x3D;boolean、I&#x3D;int、J&#x3D;long）；</p>
</li>
<li><p>引用类型：用L全类名;表示（如Ljava&#x2F;lang&#x2F;String;）；</p>
</li>
<li><p>数组类型：用[类型表示（如[I&#x3D;int[]、[[Ljava&#x2F;lang&#x2F;Object;&#x3D;Object[][]）；</p>
</li>
<li><p>方法签名：(参数类型列表)返回类型（如(II)I表示接收两个 int 参数，返回 int）。</p>
</li>
</ul>
<h2 id="2-4-第三步：编写原生实现代码（-c-cpp）"><a href="#2-4-第三步：编写原生实现代码（-c-cpp）" class="headerlink" title="2.4 第三步：编写原生实现代码（.c&#x2F;.cpp）"></a>2.4 第三步：编写原生实现代码（.c&#x2F;.cpp）</h2><p>原生实现代码需包含生成的 JNI 头文件，按照头文件中的函数声明实现具体逻辑，核心是通过JNIEnv指针调用 JNI API，完成与 Java 层的数据交互。</p>
<p>示例：JavaNativeDemo.c</p>
<p>核心 API 解析：</p>
<p>字符串处理 API：</p>
<ul>
<li><p>GetStringUTFChars(env, jstr, isCopy)：将 jstring 转换为 UTF-8 编码的 C 字符串，isCopy表示是否返回副本（通常传 NULL）；</p>
</li>
<li><p>ReleaseStringUTFChars(env, jstr, cstr)：释放GetStringUTFChars分配的内存，必须调用，否则内存泄漏；</p>
</li>
<li><p>NewStringUTF(env, cstr)：将 UTF-8 编码的 C 字符串转换为 jstring（Java 字符串）。</p>
</li>
</ul>
<p>数组处理 API：</p>
<ul>
<li><p>GetArrayLength(env, jarr)：获取 Java 数组的长度；</p>
</li>
<li><p>GetIntArrayElements(env, jarr, isCopy)：获取 int 数组的原生指针（jint*），其他类型数组对应GetXxxArrayElements；</p>
</li>
<li><p>ReleaseIntArrayElements(env, jarr, carr, mode)：释放数组资源，mode参数：</p>
</li>
<li><p>0：将原生数组的修改复制回 Java 数组，并释放原生数组；</p>
</li>
<li><p>JNI_ABORT：不复制修改，直接释放原生数组；</p>
</li>
<li><p>JNI_COMMIT：复制修改，但不释放原生数组（需后续再次调用释放）。</p>
</li>
</ul>
<p>资源释放原则：</p>
<ul>
<li><p>凡是通过 JNI API 获取的原生资源（如 C 字符串、数组指针、对象引用），必须在使用完毕后调用对应的释放 API；</p>
</li>
<li><p>释放顺序与获取顺序相反（如先获取字符串，再获取数组，则先释放数组，再释放字符串）；</p>
</li>
<li><p>若中间步骤出错（如数组获取失败），需先释放已获取的资源，再返回错误。</p>
</li>
</ul>
<h2 id="2-5-第四步：编译原生代码为动态链接库"><a href="#2-5-第四步：编译原生代码为动态链接库" class="headerlink" title="2.5 第四步：编译原生代码为动态链接库"></a>2.5 第四步：编译原生代码为动态链接库</h2><p>将原生代码（.c&#x2F;.cpp）编译为目标平台的动态链接库（Windows：.dll，Linux：.so，MacOS：.dylib），供 Java 虚拟机加载。编译时需指定 JNI 头文件路径、目标平台架构等参数。</p>
<h3 id="2-5-1-Linux-平台（GCC）"><a href="#2-5-1-Linux-平台（GCC）" class="headerlink" title="2.5.1 Linux 平台（GCC）"></a>2.5.1 Linux 平台（GCC）</h3><blockquote>
<p># 编译命令：生成libJavaNativeDemo.so</p>
<p>gcc -fPIC -shared -o libJavaNativeDemo.so \</p>
<p>-I$JAVA_HOME&#x2F;include \</p>
<p>-I$JAVA_HOME&#x2F;include&#x2F;linux \</p>
<p>JavaNativeDemo.c</p>
<p>参数说明：</p>
<ul>
<li><p>-fPIC：生成位置无关代码（Position Independent Code），确保库可被多个进程共享；</p>
</li>
<li><p>-shared：生成动态链接库（而非可执行文件）；</p>
</li>
<li><p>-o：指定输出库文件名（必须以 lib 开头，后缀为.so）；</p>
</li>
<li><p>-I：指定头文件搜索路径（需包含 JNI 头文件所在目录，$JAVA_HOME 为 JDK 安装目录）。</p>
</li>
</ul>
</blockquote>
<h3 id="2-5-2-Windows-平台（MinGW）"><a href="#2-5-2-Windows-平台（MinGW）" class="headerlink" title="2.5.2 Windows 平台（MinGW）"></a>2.5.2 Windows 平台（MinGW）</h3><blockquote>
<p># 编译命令：生成JavaNativeDemo.dll</p>
<p>gcc -shared -o JavaNativeDemo.dll \</p>
<p>-I%JAVA_HOME%\include \</p>
<p>-I%JAVA_HOME%\include\win32 \</p>
<p>JavaNativeDemo.c -Wl,–add-stdcall-alias</p>
<p>参数说明：</p>
<ul>
<li><p>-Wl,–add-stdcall-alias：为函数添加 stdcall 调用约定的别名，确保 Java 虚拟机能找到函数；</p>
</li>
<li><p>库文件名无需带 lib 前缀，后缀为.dll。</p>
</li>
</ul>
</blockquote>
<h3 id="2-5-3-MacOS-平台（Clang）"><a href="#2-5-3-MacOS-平台（Clang）" class="headerlink" title="2.5.3 MacOS 平台（Clang）"></a>2.5.3 MacOS 平台（Clang）</h3><blockquote>
<p># 编译命令：生成libJavaNativeDemo.dylib</p>
<p>clang -fPIC -shared -o libJavaNativeDemo.dylib \</p>
<p>-I$JAVA_HOME&#x2F;include \</p>
<p>-I$JAVA_HOME&#x2F;include&#x2F;darwin \</p>
<p>JavaNativeDemo.c</p>
</blockquote>
<h2 id="2-6-第五步：运行-Java-程序测试"><a href="#2-6-第五步：运行-Java-程序测试" class="headerlink" title="2.6 第五步：运行 Java 程序测试"></a>2.6 第五步：运行 Java 程序测试</h2><p>编译生成动态链接库后，需将库文件所在路径添加到 Java 虚拟机的库搜索路径中，然后运行 Java 程序。</p>
<p>运行步骤：</p>
<ol>
<li><p>将动态链接库复制到 Java 程序的运行目录，或指定库路径；</p>
</li>
<li><p>执行 Java 程序：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Linux/MacOS：通过-Djava.library.path指定库路径（当前目录用.表示）</span><br><span class="line"></span><br><span class="line">java -Djava.library.path=. com.example.jni.JavaNativeDemo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Windows：</span><br><span class="line"></span><br><span class="line">java -Djava.library.path=. com.example.jni.JavaNativeDemo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">预期输出：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原生代码返回的消息：Hello from C Native Code!</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> + <span class="number">20</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">处理后的结果：Input String: Hello JNI</span><br><span class="line"></span><br><span class="line">Array Elements: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">Array Sum: <span class="number">15</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>若运行成功，说明 JNI 调用正常；若出现UnsatisfiedLinkError（找不到库或方法），需检查以下问题：</p>
<ul>
<li><p>库文件名是否与System.loadLibrary()中的名称一致；</p>
</li>
<li><p>库路径是否正确（通过-Djava.library.path指定）；</p>
</li>
<li><p>原生函数名是否与头文件中的声明完全一致（包括包名、类名、方法名）；</p>
</li>
<li><p>编译时的 JDK 版本与运行时的 JDK 版本是否一致。</p>
</li>
</ul>
<h1 id="三、JNI-进阶特性：对象操作、异常处理与线程管理"><a href="#三、JNI-进阶特性：对象操作、异常处理与线程管理" class="headerlink" title="三、JNI 进阶特性：对象操作、异常处理与线程管理"></a>三、JNI 进阶特性：对象操作、异常处理与线程管理</h1><h2 id="3-1-访问-Java-对象的字段与方法"><a href="#3-1-访问-Java-对象的字段与方法" class="headerlink" title="3.1 访问 Java 对象的字段与方法"></a>3.1 访问 Java 对象的字段与方法</h2><p>原生代码不仅能接收 Java 传递的参数，还能主动访问 Java 对象的字段（成员变量）和调用 Java 对象的方法，这是 JNI 双向交互的核心能力。</p>
<h3 id="3-1-1-访问-Java-字段"><a href="#3-1-1-访问-Java-字段" class="headerlink" title="3.1.1 访问 Java 字段"></a>3.1.1 访问 Java 字段</h3><p>访问 Java 字段的步骤：</p>
<ol>
<li><p>通过FindClass()获取 Java 类对象（jclass）；</p>
</li>
<li><p>通过GetFieldID()获取字段 ID（jfieldID），需指定字段名和字段签名；</p>
</li>
<li><p>通过GetXxxField()&#x2F;SetXxxField()获取 &#x2F; 修改字段值（Xxx 对应字段类型）。</p>
</li>
</ol>
<p>示例：访问 Java 对象的字段</p>
<p>假设 Java 类中添加字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaNativeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段（非静态）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;默认名称&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// native方法：修改实例字段和静态字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">modifyFields</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// getter方法：用于验证字段是否被修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>原生实现代码：</p>
<h3 id="3-1-2-调用-Java-方法"><a href="#3-1-2-调用-Java-方法" class="headerlink" title="3.1.2 调用 Java 方法"></a>3.1.2 调用 Java 方法</h3><p>调用 Java 方法的步骤：</p>
<ol>
<li><p>获取 Java 类对象（jclass）；</p>
</li>
<li><p>通过GetMethodID()&#x2F;GetStaticMethodID()获取方法 ID（jmethodID），需指定方法名和方法签名；</p>
</li>
<li><p>通过CallXxxMethod()&#x2F;CallStaticXxxMethod()调用方法（Xxx 对应返回值类型）。</p>
</li>
</ol>
<p>示例：调用 Java 对象的方法</p>
<p>假设 Java 类中添加方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaNativeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法：接收字符串参数，返回拼接结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">appendString</span><span class="params">(String suffix)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Java方法返回：&quot;</span> + suffix;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法：接收两个int参数，返回乘积</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// native方法：调用Java实例方法和静态方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">callJavaMethods</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>原生实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_example_jni_JavaNativeDemo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_com_example_jni_JavaNativeDemo_callJavaMethods</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">jclass clazz = (*env)-&gt;<span class="built_in">GetObjectClass</span>(env, thiz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 调用实例方法appendString(String)：String appendString(String)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法签名：(Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line">jmethodID appendMethodId = (*env)-&gt;<span class="built_in">GetMethodID</span>(env, clazz, <span class="string">&quot;appendString&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (appendMethodId == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">(*env)-&gt;<span class="built_in">DeleteLocalRef</span>(env, clazz);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jstring suffix = (*env)-&gt;<span class="built_in">NewStringUTF</span>(env, <span class="string">&quot;来自原生代码的参数&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用实例方法：CallObjectMethod（返回值为对象类型）</span></span><br><span class="line"></span><br><span class="line">jstring appendResult = (*env)-&gt;<span class="built_in">CallObjectMethod</span>(env, thiz, appendMethodId, suffix);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>关键注意事项：</p>
<ul>
<li><p>字段 &#x2F; 方法签名必须准确，否则GetFieldID()&#x2F;GetMethodID()会返回 NULL；</p>
</li>
<li><p>访问私有字段 &#x2F; 方法时，无需额外权限（JNI 可绕过 Java 的访问控制）；</p>
</li>
<li><p>若 Java 方法抛出异常，CallXxxMethod()会返回默认值（如 0、NULL），需通过ExceptionCheck()检查异常。</p>
</li>
</ul>
<h2 id="3-2-JNI-异常处理"><a href="#3-2-JNI-异常处理" class="headerlink" title="3.2 JNI 异常处理"></a>3.2 JNI 异常处理</h2><p>Java 层的异常会传递到原生层，原生层也可能产生异常（如数组越界、空指针），需通过 JNI 的异常处理 API 进行捕获和处理，避免程序崩溃。</p>
<p>JNI 异常处理核心 API：</p>
<ul>
<li><p>ExceptionCheck(env)：检查是否有未处理的异常，返回 JNI_TRUE&#x2F;JNI_FALSE；</p>
</li>
<li><p>ExceptionOccurred(env)：获取当前异常对象（jthrowable），若无不返回 NULL；</p>
</li>
<li><p>ExceptionDescribe(env)：打印异常堆栈信息（类似 Java 的 printStackTrace ()）；</p>
</li>
<li><p>ExceptionClear(env)：清除当前异常，使程序可继续执行；</p>
</li>
<li><p>Throw(env, exc)：抛出已存在的异常对象；</p>
</li>
<li><p>ThrowNew(env, clazzName, msg)：创建并抛出新的异常（需指定异常类名，如 “java&#x2F;lang&#x2F;NullPointerException”）。</p>
</li>
</ul>
<p>示例：原生代码中的异常处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;com_example_jni_JavaNativeDemo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_com_example_jni_JavaNativeDemo_divide</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">(JNIEnv *env, jobject thiz, jint a, jint b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查除数为0的情况，主动抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并抛出ArithmeticException异常</span></span><br><span class="line"></span><br><span class="line">(*env)-&gt;<span class="built_in">ThrowNew</span>(env, (*env)-&gt;<span class="built_in">FindClass</span>(env, <span class="string">&quot;java/lang/ArithmeticException&quot;</span>), <span class="string">&quot;除数不能为0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回默认值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jint result = a / b;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>&#x2F;&#x2F; 模拟Java方法调用可能抛出的异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">jclass</span> <span class="variable">clazz</span> <span class="operator">=</span> (*env)-&gt;GetObjectClass(env, thiz);</span><br><span class="line"></span><br><span class="line"><span class="type">jmethodID</span> <span class="variable">testMethodId</span> <span class="operator">=</span> (*env)-&gt;GetMethodID(env, clazz, <span class="string">&quot;testException&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>异常处理原则：</p>
<ul>
<li><p>原生代码中检测到非法条件时，应主动抛出 Java 异常（而非直接崩溃），使 Java 层能捕获处理；</p>
</li>
<li><p>调用 JNI API 或 Java 方法后，需检查是否产生异常，及时处理（清除或抛出）；</p>
</li>
<li><p>异常未清除前，除异常处理相关 API 外，不应调用其他 JNI API（否则行为未定义）。</p>
</li>
</ul>
<h2 id="3-3-JNI-线程管理"><a href="#3-3-JNI-线程管理" class="headerlink" title="3.3 JNI 线程管理"></a>3.3 JNI 线程管理</h2><p>Java 虚拟机中的线程（Java 线程）与原生代码中的线程（原生线程）可通过 JNI 进行交互：Java 线程可调用原生代码，原生线程也可附着到 Java 虚拟机，调用 Java 方法。</p>
<h3 id="3-3-1-原生线程附着到-Java-虚拟机"><a href="#3-3-1-原生线程附着到-Java-虚拟机" class="headerlink" title="3.3.1 原生线程附着到 Java 虚拟机"></a>3.3.1 原生线程附着到 Java 虚拟机</h3><p>原生线程（如 C 语言创建的 pthread 线程）默认未附着到 Java 虚拟机，无法调用 JNI API，需通过AttachCurrentThread()将其附着到虚拟机，使用完毕后通过DetachCurrentThread()分离。</p>
<p>示例：原生线程附着到 Java 虚拟机</p>
<p>Java 类中添加回调方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaNativeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态回调方法：供原生线程调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onNativeThreadCallback</span><span class="params">(String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Java收到原生线程的消息：&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// native方法：创建原生线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">createNativeThread</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>线程管理关键要点：</p>
<ul>
<li><p>JavaVM指针：全局唯一，可在多个线程间共享，用于获取当前线程的JNIEnv指针；</p>
</li>
<li><p>JNIEnv指针：线程私有，每个线程的JNIEnv指针不同，不能跨线程使用；</p>
</li>
<li><p>全局引用：需手动释放（DeleteGlobalRef），否则内存泄漏；局部引用：在方法返回时自动释放，但建议手动释放以节省内存；</p>
</li>
<li><p>原生线程附着后必须分离（DetachCurrentThread），否则会导致 Java 虚拟机无法正常退出。</p>
</li>
</ul>
<h1 id="四、JNI-性能优化与避坑指南"><a href="#四、JNI-性能优化与避坑指南" class="headerlink" title="四、JNI 性能优化与避坑指南"></a>四、JNI 性能优化与避坑指南</h1><h2 id="4-1-性能优化技巧"><a href="#4-1-性能优化技巧" class="headerlink" title="4.1 性能优化技巧"></a>4.1 性能优化技巧</h2><p>JNI 调用本身存在一定的性能开销（如参数转换、虚拟机上下文切换），尤其是高频调用场景，需通过以下技巧优化性能：</p>
<h3 id="4-1-1-减少-JNI-调用次数"><a href="#4-1-1-减少-JNI-调用次数" class="headerlink" title="4.1.1 减少 JNI 调用次数"></a>4.1.1 减少 JNI 调用次数</h3><p>JNI 调用的开销远大于 Java 方法调用，应尽量将多个小操作合并为一个原生函数调用，减少跨语言交互次数。例如，若需多次读取 Java 数组元素，不应每次读取都调用GetIntArrayElements，而应一次性获取数组指针，批量处理后再释放。</p>
<h3 id="4-1-2-缓存全局引用"><a href="#4-1-2-缓存全局引用" class="headerlink" title="4.1.2 缓存全局引用"></a>4.1.2 缓存全局引用</h3><p>频繁调用FindClass、GetMethodID、GetFieldID等 API 会产生较大开销，因为这些 API 需要在 Java 虚拟机的元数据中查找信息。建议在JNI_OnLoad中初始化这些 ID，并保存为全局变量（如全局类引用、全局方法 ID），避免每次调用都重复查找。</p>
<h3 id="4-1-3-优化数据拷贝"><a href="#4-1-3-优化数据拷贝" class="headerlink" title="4.1.3 优化数据拷贝"></a>4.1.3 优化数据拷贝</h3><p>Java 数组与原生数组之间的转换会涉及数据拷贝（GetXxxArrayElements默认会复制数组数据），可通过以下方式减少拷贝：</p>
<ul>
<li><p>使用GetPrimitiveArrayCritical&#x2F;ReleasePrimitiveArrayCritical：获取数组的直接指针（避免拷贝），但调用期间会暂停 Java 虚拟机的垃圾回收（GC），需尽快释放，且不能调用其他 JNI API；</p>
</li>
<li><p>对于大量数据传输，使用java.nio缓冲区（如DirectByteBuffer），直接在原生代码中操作缓冲区的内存，无需数据拷贝。</p>
</li>
</ul>
<h3 id="4-1-4-避免在原生代码中长时间阻塞"><a href="#4-1-4-避免在原生代码中长时间阻塞" class="headerlink" title="4.1.4 避免在原生代码中长时间阻塞"></a>4.1.4 避免在原生代码中长时间阻塞</h3><p>原生代码中的长时间阻塞（如睡眠、IO 等待）会导致 Java 线程阻塞，若持有 JNI 锁或暂停 GC，会影响虚拟机的正常运行。建议：</p>
<ul>
<li><p>长时间阻塞的操作放在独立的原生线程中执行；</p>
</li>
<li><p>避免在GetPrimitiveArrayCritical调用期间进行阻塞操作。</p>
</li>
</ul>
<h2 id="4-2-常见坑与解决方案"><a href="#4-2-常见坑与解决方案" class="headerlink" title="4.2 常见坑与解决方案"></a>4.2 常见坑与解决方案</h2><h3 id="4-2-1-内存泄漏"><a href="#4-2-1-内存泄漏" class="headerlink" title="4.2.1 内存泄漏"></a>4.2.1 内存泄漏</h3><p>JNI 中最常见的问题是内存泄漏，主要源于未释放的资源：</p>
<ul>
<li><p>局部引用未释放：虽然局部引用会在方法返回时自动释放，但如果原生函数执行时间长、创建大量局部引用（如循环创建 jstring），会导致虚拟机内存溢出，需手动调用DeleteLocalRef释放；</p>
</li>
<li><p>全局引用未释放：全局引用不会自动释放，必须在使用完毕后调用DeleteGlobalRef，否则会导致对应的 Java 对象无法被 GC 回收；</p>
</li>
<li><p>字符串 &#x2F; 数组资源未释放：GetStringUTFChars、GetIntArrayElements等 API 分配的原生资源，必须调用对应的ReleaseXxx方法释放。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>遵循 “谁获取，谁释放” 的原则，确保每个获取资源的 API 都有对应的释放操作；</p>
</li>
<li><p>使用工具检测内存泄漏：如 VisualVM（监控 Java 堆内存）、Valgrind（检测原生代码的内存泄漏）。</p>
</li>
</ul>
<h3 id="4-2-2-UnsatisfiedLinkError"><a href="#4-2-2-UnsatisfiedLinkError" class="headerlink" title="4.2.2 UnsatisfiedLinkError"></a>4.2.2 UnsatisfiedLinkError</h3><p>该异常表示 Java 虚拟机找不到指定的原生库或原生函数，常见原因：</p>
<ul>
<li><p>库路径错误：未通过-Djava.library.path指定库所在路径；</p>
</li>
<li><p>库文件名错误：如 Linux 平台库名未以lib开头，Windows 平台后缀不是.dll；</p>
</li>
<li><p>函数名不一致：原生函数名与头文件中的声明不一致（如包名、类名拼写错误）；</p>
</li>
<li><p>编译架构不匹配：如 Java 虚拟机是 64 位，而原生库是 32 位；</p>
</li>
<li><p>JNI 版本不兼容：编译时使用的 JDK 版本与运行时的 JDK 版本差异过大。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>仔细检查库路径、文件名、函数名是否正确；</p>
</li>
<li><p>使用nm命令（Linux&#x2F;MacOS）或dumpbin命令（Windows）查看原生库中的函数名，确认是否与预期一致；</p>
</li>
<li><p>确保编译架构与 Java 虚拟机一致（64 位对 64 位，32 位对 32 位）。</p>
</li>
</ul>
<h3 id="4-2-3-空指针异常"><a href="#4-2-3-空指针异常" class="headerlink" title="4.2.3 空指针异常"></a>4.2.3 空指针异常</h3><p>原生代码中的空指针异常（如访问NULL的 jobject、jstring）会导致 Java 虚拟机崩溃（而非 Java 的NullPointerException），难以调试：</p>
<ul>
<li><p>原因：Java 层传递null给 native 方法（如 jstring 为 NULL），原生代码未做检查直接使用；</p>
</li>
<li><p>解决方案：在原生代码中对接收的参数进行空指针检查，如：</p>
</li>
</ul>
<p>if (input &#x3D;&#x3D; NULL) {</p>
<p>(*env)-&gt;ThrowNew(env, (*env)-&gt;FindClass(env, “java&#x2F;lang&#x2F;NullPointerException”), “input参数不能为null”);</p>
<p>return NULL;</p>
<p>}</p>
<h3 id="4-2-4-线程安全问题"><a href="#4-2-4-线程安全问题" class="headerlink" title="4.2.4 线程安全问题"></a>4.2.4 线程安全问题</h3><p>原生代码通常不具备线程安全，若多个 Java 线程同时调用同一个原生函数，可能导致数据竞争：</p>
<ul>
<li><p>解决方案：</p>
</li>
<li><p>在原生代码中使用互斥锁（如 pthread_mutex_t）保护共享资源；</p>
</li>
<li><p>避免在原生代码中使用全局变量存储状态，或确保全局变量的线程安全访问。</p>
</li>
</ul>
<h3 id="4-2-5-跨平台兼容性问题"><a href="#4-2-5-跨平台兼容性问题" class="headerlink" title="4.2.5 跨平台兼容性问题"></a>4.2.5 跨平台兼容性问题</h3><p>原生代码的跨平台兼容性差，同样的代码在 Windows 上编译通过，在 Linux 上可能报错：</p>
<ul>
<li><p>原因：</p>
</li>
<li><p>操作系统 API 差异（如文件操作、线程创建的 API 不同）；</p>
</li>
<li><p>数据类型大小差异（如某些平台long是 4 字节，某些是 8 字节）；</p>
</li>
<li><p>编译选项差异（如 Windows 需要__stdcall调用约定）。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>尽量使用标准 C&#x2F;C++ 库，避免直接调用操作系统 API；</p>
</li>
<li><p>对于平台相关的代码，使用条件编译（如#ifdef _WIN32、#ifdef <strong>linux</strong>）；</p>
</li>
<li><p>统一编译选项，确保不同平台生成的库符合 JNI 规范。</p>
</li>
</ul>
<h1 id="五、JNI-与其他跨语言方案对比"><a href="#五、JNI-与其他跨语言方案对比" class="headerlink" title="五、JNI 与其他跨语言方案对比"></a>五、JNI 与其他跨语言方案对比</h1><p>除了 JNI，Java 还有其他跨语言调用方案，如 JNA、SWIG、JNR 等，各有优劣，需根据场景选择：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>核心优势</th>
<th>核心劣势</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>JNI</td>
<td>性能最优，直接与虚拟机交互，功能最全面</td>
<td>开发复杂，需手动编写原生代码和头文件，易出错</td>
<td>性能要求高、需深度访问底层资源的场景（如音视频编解码、驱动开发）</td>
</tr>
<tr>
<td>JNA</td>
<td>开发简单，无需编写原生代码，直接映射 Java 接口到原生库</td>
<td>性能略低于 JNI，不支持某些 JNI 高级特性（如原生线程附着）</td>
<td>快速整合第三方原生库，无需优化性能的场景</td>
</tr>
<tr>
<td>SWIG</td>
<td>自动生成 JNI 包装代码，支持多种语言（Java、Python 等）</td>
<td>配置复杂，生成的代码可读性差，难以调试</td>
<td>需跨多种语言复用原生库的场景</td>
</tr>
<tr>
<td>JNR</td>
<td>基于 JNI 的封装，开发简单，性能接近 JNI</td>
<td>生态不如 JNA 成熟，支持的原生库特性有限</td>
<td>对性能有要求且希望简化开发的场景</td>
</tr>
</tbody></table>
<p>选择建议：</p>
<ul>
<li><p>若追求极致性能和全面功能，选择 JNI；</p>
</li>
<li><p>若开发效率优先，需快速整合第三方库，选择 JNA；</p>
</li>
<li><p>若需跨多种语言复用原生库，选择 SWIG。</p>
</li>
</ul>
<h1 id="六、总结与展望"><a href="#六、总结与展望" class="headerlink" title="六、总结与展望"></a>六、总结与展望</h1><p>JNI 作为 Java 与原生世界的桥梁，为 Java 提供了访问底层资源、复用原生代码、优化性能的强大能力，是 Android、大数据、金融等领域不可或缺的技术。但 JNI 的开发门槛较高，需要开发者同时掌握 Java 和 C&#x2F;C++ 语言，且需严格遵循内存管理、线程安全等规则，否则容易引入难以调试的问题。</p>
<p>本文从基础概念、开发流程、进阶特性到性能优化，全面覆盖了 JNI 的核心知识，并通过实战案例帮助开发者快速上手。掌握 JNI 的关键在于理解其架构原理和 API 设计思想，同时注重细节（如资源释放、异常处理），避免常见坑。</p>
<p>随着 Java 技术的发展，JNI 也在不断演进：JDK 9 引入的Foreign Linker API（孵化特性）旨在提供更安全、更易用的跨语言调用方案，减少 JNI 的复杂性；GraalVM 等新一代虚拟机也对 JNI 提供了更好的支持和性能优化。但在可预见的未来，JNI 仍将是 Java 生态中不可或缺的一部分，尤其是在需要深度整合底层系统的场景中。</p>
<p>希望本文能帮助开发者真正掌握 JNI 技术，在实际项目中灵活运用，充分发挥 Java 与原生代码的优势，构建高性能、高可靠性的软件系统。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/12/23/JNI-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E-Java-%E5%88%B0-Native-%E7%9A%84%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E6%88%98/" data-id="cuid_Ekzf14yC9vHyQ8ya8SRS" data-title="JNI 完全指南：从 Java 到 Native 的深度探索与实战" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/12/23/DoraemonKit%EF%BC%88DoKit%EF%BC%89%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BB%8E%E9%9B%86%E6%88%90%E5%88%B0%E5%AE%9E%E6%88%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          DoraemonKit（DoKit）使用教程：从集成到实战
        
      </div>
    </a>
  
  
    <a href="/2025/12/23/OpenSL-ES-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%AB%98%E6%80%A7%E8%83%BD%E9%9F%B3%E9%A2%91%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">OpenSL ES 完全指南：移动端高性能音频开发实战</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" rel="tag">代码拉取</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" rel="tag">文章，博客框架，技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" rel="tag">服务器，游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" rel="tag">权限配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E6%8B%89%E5%8F%96/" style="font-size: 10px;">代码拉取</a> <a href="/tags/%E6%96%87%E7%AB%A0%EF%BC%8C%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%EF%BC%8C%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">文章，博客框架，技术</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">服务器，游戏</a> <a href="/tags/%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">权限配置</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">十二月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/12/25/gitLaB%E9%97%AE%E9%A2%98/">gitLaB问题</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83/">大模型微调</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E9%87%8C%E9%9D%A2%E7%9A%84%E2%80%98mcp%E2%80%99%E6%8A%80%E6%9C%AF/">计算机技术里面的‘mcp’技术</a>
          </li>
        
          <li>
            <a href="/2025/12/24/2025-8-19/">2025-8-19</a>
          </li>
        
          <li>
            <a href="/2025/12/24/%E9%82%A3%E4%BA%9B%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84-%E8%B6%85%E7%BA%A7%E9%BB%84%E9%87%91-bug-%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%AF%A5%E8%AE%B0%E5%8F%96%E7%9A%84%E8%A1%80%E6%B3%AA%E7%BB%8F%E9%AA%8C/">那些在公司工作中遇到的 &#39;超级黄金 bug&#39;：每个程序员都该记取的血泪经验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 little chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>